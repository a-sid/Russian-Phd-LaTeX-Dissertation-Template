\pdfoptionpdfminorversion=5
\documentclass[hyperref={pdfpagelabels=false},10pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amssymb,amsfonts,amsmath,mathtext}
\usepackage{cite,enumerate,float,indentfirst}
\usepackage{listings}
 
\usepackage{tikz}
\usetikzlibrary{positioning,arrows,matrix}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
  numbers=left,
}

\lstset{escapechar=@,style=customc}


\graphicspath{{images/}}

\usetheme{Pittsburgh}
\usecolortheme{whale}

% \usepackage[defaultsans]{opensans}
% \renewcommand*\familydefault{\sfdefault} %% Only if the base font of the document is to be typewriter style
\usepackage[T2A]{fontenc}

\setbeamercolor{footline}{fg=blue}
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{}%
    А.В.~Сидорин, МГТУ им. Баумана
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{}%
    Москва, 2015
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{}%
  Стр. \insertframenumber{} из \inserttotalframenumber \hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}

\newcommand{\itemi}{\item[\checkmark]}

\title{Разработка и  исследование методов межпроцедурного и межмодульного анализа кодов программ, написанных на~языках  С и С++, применимых для~анализа крупных систем}
\author{\small{%
\emph{Выступающий:}~А.В.~Сидорин\\%
\emph{Руководитель:}~доцент,~к.ф.-м.н.~Т.Н.~Романова}\\%
\vspace{30pt}%
Московский государственный технический университет\\имени Н.\,Э.~Баумана%
\vspace{10pt}%
}
\date{\small{Москва, 2015}}

\begin{document}

\maketitle

%--------------------------------------------------------------------------------------------------------
\begin{frame}
\frametitle{Крупные и сложные программные системы}
\begin{figure}[h]
  \center{\includegraphics[width=\linewidth]{../Dissertation/images/complexity.pdf}}

% \begin{tikzpicture}[ampersand replacement=\&,
%                     thick,anchor=center,
%                     text height=4ex,
%                     text depth=.25ex,
%                     text centered]
% \tikzstyle{format} = [thick,
%                       minimum size=1cm,
%                       draw=black,
%                       top color=white,
%                       align=center,anchor=center,
%                     font=\tiny,]
%   \matrix (mat) [matrix of nodes, nodes=format, column sep=5mm, row sep=5mm] 
% {
% \& \& \node[format] (comp-def) {Сложность\\программных\\систем}; \& \& \\
% \node[format] (dyn) {Динамическая}; \& \node[format] (comp-term) {Структурная}; \& \node[format] (info) {Информационная}; \& \node[format] (comput) {Вычислительная};  \& \node[format] (algo) {Алгоритмическая}; \\
% \node[format] (dyn-def) {Сложная\\динамика\\системы}; \& \node[format] (comp-conc)  {Трудно\\отслеживаемые\\связи}; \& \node[format] (info-def) {Сложное\\описание\\системы}; \& \node[format] (comput-def) {Сложность\\прогнозирования\\и расчёта};  \& \node[format] (algo-def) {Сложность\\функционального\\описания}; \\
% };
% \path[->] (comp-def) edge node {} (comp-term);
% \path[->] (comp-term) edge node {} (comp-conc);
% \path[->] (comp-def) edge node {} (dyn);
% \path[->] (dyn) edge node {} (dyn-def);
% \path[->] (comp-def) edge node {} (info);
% \path[->] (info) edge node {} (info-def);
% \path[->] (comp-def) edge node {} (comput);
% \path[->] (comput) edge node {} (comput-def);
% \path[->] (comp-def) edge node {} (algo);
% \path[->] (algo) edge node {} (algo-def);
% \end{tikzpicture}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------
\renewcommand{\arraystretch}{1.2}

\begin{frame}
\frametitle{Анализируемые объёмы кодов программ}
Характеристики тестовой базы ОС Android 4.2.1
\begin{table} [htbp]
  \centering
  \parbox{15cm}{\label{table:android-char}}
%  \begin{center}
  \begin{tabular}{| p{0.7\linewidth} || p{0.2\linewidth} |}
  \hline
  \hline
  \textbf{Характеристика}   & \textbf{Значение} \\
  \hline
  \hline
  Количество строк кода   & 10 млн \\
  \hline
  Количество файлов исходного кода      & 31038    \\
  \hline
  Количество транслируемых модулей  & 20635   \\
  \hline
  Количество архитектур на построение & 2   \\
  \hline
  Количество пакетов & 389 \\
  \hline
  \hline
  \end{tabular}
%  \end{center}
\end{table}
\end{frame}
%--------------------------------------------------------------------------------------------------------
\begin{frame}
\frametitle{C/C++ пакеты системы Android 4.2.1~---\\диаграмма связей}
\begin{figure}[h]
  \center{\includegraphics[height=0.65\linewidth]{../Dissertation/images/callgraph.pdf}}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Статический анализ в ЖЦ ПО}
\begin{figure}[h]
%   \begin{minipage}[h]{\linewidth}
%     \textbf{<<Водопадный>> ЖЦ}
%     \center{\includegraphics[width=1\linewidth]{../Dissertation/images/lifecycle-waterfall.pdf}}
%   \end{minipage}
  \vfill
  \begin{minipage}[h]{\linewidth}
    \textbf{ЖЦ безопасного ПО}
    \center{\includegraphics[width=1\linewidth]{../Dissertation/images/ms-sdl-sel.pdf}}
  \end{minipage}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Характеристики статического анализа}
\begin{figure}[h]
  \center{\includegraphics[width=\linewidth]{../Dissertation/images/characteristics.pdf}}
% \begin{tikzpicture}[thick,anchor=base,
%                     node distance=3cm,
%                     text height=1.5ex,
%                     text depth=.25ex,
%                     auto]
% \tikzstyle{format} = [thick,
%                       minimum size=1cm,
%                       draw=black,
%                       top color=white]
% 
% \tikzstyle{selected} = [thick,
%                       minimum size=1cm,
%                       draw=black,
%                       top color=gray]
% \node[format]       (char) {Характеристики анализа кодов программ};
% \node[selected,below of=char]  (compl) {Полнота};
% \node[selected,right of=compl] (prec)  {Точность};
% \node[format,left  of=compl] (speed) {Скорость};
% 
% \path[->] (char) edge node {} (compl);
% \path[->] (char) edge node {} (prec);
% \path[->] (char) edge node {} (speed);
% \path[<->] (prec) edge node {} (compl);
% \path[<->,draw] (speed) -- +(0,-1) -| node[near start] {} (prec);
% \path[<->] (compl) edge node {} (speed);
% \end{tikzpicture}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

% \begin{frame}
% \frametitle{Актуальность}
% Сложность систем и их критичность растёт, нужны новые методы автоматического тестирования..., универсальный анализатор, ограниченное время..., невозможность решения проблемы в общем виде, хотя отдельные формальные подходы существуют.
% \end{frame}

\begin{frame}
\frametitle{Актуальность проблемы анализа больших систем}
\begin{figure}[h]
    \center{\includegraphics[width=1\linewidth]{../Dissertation/images/problems.pdf}}

% \begin{tikzpicture}[ampersand replacement=\&,thick,anchor=center,
%                     node distance=3cm,
%                     text height=8ex,
%                     text depth=.25ex,
%                       align=center,
%                       text centered]
% \tikzstyle{format} = [anchor=center,thick,
%                       minimum size=1cm,
%                       draw=black,
%                       height=6ex,
%                       top color=white,
%                       text centered]
% 
% \tikzstyle{selected} = [thick,
%                       minimum size=1cm,
%                       draw=black,
%                       top color=gray]
%   \matrix (mat) [matrix of nodes, nodes=format, column sep=5mm, row sep=15mm] 
% {
% % TODO: s/Интеграция.../Использование на различных этапах ЖЦ
% \node[format] (int) {Использование\\на различных\\этапах ЖЦ}; \& \node[selected]       (char) {Проблемы анализа}; \& \node[format] (univ) {Универсальность};\\
% \node[format]  (compl) {Рост сложности\\программ}; \& \node[format]  (reqs) {Противоречивые\\требования\\к характеристикам\\анализа}; \& \node[format] (prec)  {Рост объёмов кода\\анализируемых\\программ}; \\
% };
% \path[->] (char) edge node {} (compl);
% \path[->] (char) edge node {} (prec);
% \path[->] (char) edge node {} (univ);
% \path[->] (char) edge node {} (int);
% \path[->] (char) edge node {} (reqs);
% \end{tikzpicture}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]

\frametitle{Метод символьного выполнения}
\begin{figure}[h]
  \begin{minipage}[h]{0.4\linewidth}
  Исходная функция
\begin{lstlisting}[language=C++,basicstyle=\tiny]
int test(int a, int b) {
  FILE *f = fopen("file.txt");
  int result;
  fscanf(f, "%d", &result);
  fclose(f);
  if (a == 0 && b > 2) {
    fclose(f);
    return 0;
  }
  return result;
}
\end{lstlisting}
  \end{minipage}
  \hfill
  \begin{minipage}[h]{0.58\linewidth}
    Результирующий граф выполнения
    \center{\includegraphics[height=1.1\linewidth]{../Dissertation/images/article-1-symexec-sample.pdf}}
  \end{minipage}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------
%TODO: Табличка положительные/отрицательные, описание метода.
\begin{frame}
\frametitle{Межпроцедурный анализ с использованием\\метода встраивания}
Межпроцедурный анализ с использованием метода встраивания моделирует вызов функции выполнением всех её операторов относительно состояния программы на момент вызова в соответствии с потоком управления внутри вызываемой функции.
\vspace{10pt}
\begin{figure}[h]
  \begin{minipage}[h]{0.49\linewidth}
  \center{Преимущества}
  \end{minipage}
  \hfill
  \begin{minipage}[h]{0.49\linewidth}
\center{Недостатки}
  \end{minipage}
  \vspace{5pt}

  \begin{minipage}[h]{0.49\linewidth}
  \begin{itemize}
    \item[+] Интуитивно понятный метод
  \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[h]{0.49\linewidth}
\begin{itemize}
 \item[--] Повторный анализ функций при моделировании вызовов
 \item[--] Непроизводительные вычисления
\end{itemize}
  \end{minipage}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Цель работы}
Разработать методы межпроцедурного и межмодульного анализа больших и сложных программных систем, реализованных на языках C и C++, для построения универсального анализатора для среды автоматического тестирования с целью повышения эффективности анализа кодов программ.
%Теоретическое обоснование и исследование подходов для модификации существующего метода межпроцедурного анализа, который будет использован для построения универсального анализатора кодов программ, разработанных с использованием языков C и C++, для дальнейшего встраивания в среду автоматического тестирования, с целью повышения эффективности анализа крупных прикладных программных комплексов
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Межпроцедурный анализ с помощью резюме}
\begin{figure}[h]
  \center{\includegraphics[width=1\linewidth]{images/summary.png}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------
\begin{frame}
\frametitle{Математическая модель\\для расчёта производительности}
Межпроцедурный анализ методом встраивания:
\begin{equation*}
 T_{\text{встраивания полное}} = T_{\text{анализа}} + \sum_{i = 0}^{n} t_i 
\end{equation*}
Межпроцедурный анализ \textit{методом резюме}:
\begin{equation*}
 T_{\text{резюме}} = T_{\text{анализа}} + T_{\text{сбора}} + \sum_{i = 0}^{n} t_{i \text{применения}}
\end{equation*}
Откуда получаем выигрыш по времени при выполнении:
\begin{equation*}
 \sum_{i = 0}^{n} t_{i \text{применения}} <  \sum_{i = 0}^{n} t_i
\end{equation*}

% \begin{equation*}
%  t_{\text{ср. применения резюме}} = \frac{\sum_{i = 0}^{n} t_{i \text{применения}}}{n},
% \end{equation*}
% \begin{equation*}
%  t_{\text{ср. встраивания}} = \frac{\sum_{i = 0}^{n} t_i}{n}
% \end{equation*}

\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Учитываемые эффекты выполнения функции}
В резюме функции сохраняются следующие эффекты, влияющие на состояние программы:
\begin{figure}[h]
\begin{tikzpicture}[ampersand replacement=\&,thick,anchor=base,
                    node distance=3cm,
                  %  text height=7ex,
                    text depth=.25ex,
                      align=center]
\tikzstyle{format} = [anchor=center,thick,
                      minimum size=1cm,
                      draw=black,text centered,
                      top color=white]

\tikzstyle{selected} = [thick,anchor=center,
                      minimum size=1cm,
                      draw=black,
                      top color=gray]
  \matrix (mat) [matrix of nodes, nodes=format, column sep=5mm, row sep=15mm, align=center, ] 
{
\node[format] (int) {Модификация\\нелокальной\\памяти}; \& \node[selected]       (char) {Эффекты}; \& \node[format] (univ) {Инвалидация};\\
\node[format]  (compl) {Возврат\\значения}; \& \node[format] (lims)  {Ограничения\\входных\\данных}; \& \node[format] (prec)  {Состояния\\проверок}; \\
};
\path[->] (char) edge node {} (compl);
\path[->] (char) edge node {} (prec);
\path[->] (char) edge node {} (univ);
\path[->] (char) edge node {} (int);
\path[->] (char) edge node {} (lims);
\end{tikzpicture}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Достижимость ветвей выполнения}
Расчёт нового множества конкретных значений $R_{ij}$ для символьного значения $j$ в ветви выполнения $i$:
\begin{equation*}
\label{result_sval}
 \forall i \in [0; n], \forall j \in [0; p_i]:\ R_{\text{выходные}\ ij} =  R_{\text{входные}\ ij} \cap R_{\text{резюме}\ ij},
\end{equation*}
Отсечение недостижимых ветвей:
\begin{equation*}
 \label{empty_set}
 (\exists i, j: R_{\text{входные}\ ij} \cap R_{\text{резюме}\ ij} = \varnothing)  \Rightarrow (state_{\text{входное}} \nrightarrow state_{\text{выходное}}),
\end{equation*}
$n$~--- количество ветвей в графе выполнения,

$p_{i}$~--- количество символьных значений в $i$-й ветви выполнения.


\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Полнота анализа}
\textbf{Теорема 1}. Если при использовании проверки с помощью метода встраивания результатом проверки является предупреждение, выданное в некотором узле графа выполнения программы, то при использовании метода резюме для той же функции верхнего уровня и того же набора вызываемых функций результатом проверки методом резюме также является предупреждение, выданное в узле графа выполнения вызывающей функции или в одном из узлов графов выполнения вызываемых функций.

\vspace{10pt}
\textbf{Теорема 2}. При использовании отложенной проверки в конце анализа функции верхнего уровня при использовании МПА методом встраивания и МПА методом резюме множества срабатываний совпадают.
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Поддержка произвольных видов проверок\\в резюме}
\begin{figure}[h]
\begin{tikzpicture}[ampersand replacement=\&,thick,anchor=base,
                    node distance=3cm,
                  %  text height=7ex,
                    text depth=.25ex,
                      align=center]
\tikzstyle{format} = [anchor=center,thick,
                      minimum size=1cm,
                      draw=black,text centered,
                      top color=white]

\tikzstyle{selected} = [thick,anchor=center,
                      minimum size=1cm,
                      draw=black,
                      top color=gray]
  \matrix (mat) [matrix of nodes, nodes=format, column sep=5mm, row sep=15mm, align=center, ] 
{
\& \node[selected]       (char) {Поддержка произвольных\\проверок}; \& \\
\node[format]  (compl) {Отложенные\\проверки}; \& \node[format]  (univ) {Поддержка\\метаданных}; \& \node[format] (prec)  {Состояние\\проверки}; \\
};
\path[->] (char) edge node {} (compl);
\path[->] (char) edge node {} (prec);
\path[->] (char) edge node {} (univ);
\end{tikzpicture}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Актуализация символьных значений}

\begin{enumerate}
 \item Для всех регионов памяти, содержащихся в символьном значении:
 \begin{enumerate}
  \item Определить регион, соответствующий данному региону в вызывающей функции
  \item Заменить в символьном значении исходный регион актуализированным
 \end{enumerate}
 \item Для всех символов, содержащихся в символьном значении, полученном на шаге 1:
  \begin{enumerate}
  \item Проверить, не вычисляется ли символ в константу
  \item Если символ вычисляется в константу, заменить данный символ вычисленной константой.
 \end{enumerate}

\end{enumerate}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Построение отчёта однократной вложенности}
Отчёт строится с помощью последовательного движения по графам выполнения вызываемой и вызывающей функции.

\begin{figure}[H]
  \center{\includegraphics[width=0.8\linewidth]{../Dissertation/images/call-trace-2.pdf}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Построение отчёта произвольной вложенности}
При хранении всего стека применения резюме можно строить отчёты произвольной вложенности аналогичным способом.
\begin{figure}[h]
  \center{\includegraphics[width=1\linewidth]{../Dissertation/images/call-trace-multiple-2.pdf}}
\end{figure}
\end{frame}


%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Межмодульный анализ}
Функциональная модель межмодульного анализа, используемая в разработанном ПО, представлена в нотации IDEF0.
\begin{figure}[h]
  \center{\includegraphics[width=\linewidth]{../Dissertation/images/xtu-idef0-4.pdf}}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------
\begin{frame}
\frametitle{Слияние АСД}
\begin{figure}[h]
  \begin{minipage}[h]{0.49\linewidth}
\begin{itemize}
 \item[+] Прозрачный межмодульный анализ
 \item[+] Возможность выполнения комбинированных проверок
 \item[+] Отсутствие потерь информации о программе
\end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[h]{0.49\linewidth}
\begin{itemize}
 \item[--] Проблема конфликтующих определений
 \item[--] Проблема слияния АСД кода, разработанного с использованием различных стандартов языка
\end{itemize}
  \end{minipage}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Тестирование разработного ПО при анализе исходного кода ОС Android 4.2.1 (около 10 млн. строк кода)}
Зависимость количества обрабатываемых узлов графа выполнения от времени  при \textbf{внутримодульном анализе}
\begin{figure}[h]
  \center{\includegraphics[width=0.75\linewidth]{../Dissertation/images/single-nodes.pdf}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Тестирование разработного ПО при анализе исходного кода ОС Android 4.2.1 (около 10 млн. строк кода)}
Зависимость количества обрабатываемых узлов графа выполнения от времени  при \textbf{межмодульном анализе}
\begin{figure}[h]
  \center{\includegraphics[width=0.75\linewidth]{../Dissertation/images/xtu-nodes.pdf}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Тестирование разработного ПО при анализе исходного кода ОС Android 4.2.1 (около 10 млн. строк кода)}
Зависимость количества уникальных отчётов о дефектах от времени  при \textbf{внутримодульном анализе}
\begin{figure}[h]
  \center{\includegraphics[width=0.75\linewidth]{../Dissertation/images/single-unique.pdf}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Тестирование разработного ПО при анализе исходного кода ОС Android 4.2.1 (около 10 млн. строк кода)}
Зависимость количества уникальных отчётов о дефектах от времени  при \textbf{межмодульном анализе}

\begin{figure}[h]
  \center{\includegraphics[width=0.75\linewidth]{../Dissertation/images/xtu-unique.pdf}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\begin{center}
Спасибо за внимание!
\end{center}
\end{frame}


% \begin{frame}
% \frametitle{Цель работы}
% \begin{itemize}
%   \item Построение метода анализа крупных программных комплексов, разработанных с использованием языков C и C++, способного осуществлять анализ проектов масштаба ОС Android и ОС Tizen (порядка 5--20~млн. строк кода) за приемлемое время и обеспечивающего достаточное покрытие путей выполнения программы.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Актуальные проблемы статического анализа}
% \begin{itemize}
%   \item Необходимость поиска компромисса между качеством, полнотой и временем анализа
%   \item Экспоненциальная сложность наиболее точных и полных видов статического анализа делает их ограниченно применимыми для анализа крупных программных систем
%   \item Проблема улучшения производительности методов статического анализа является актуальной   
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Поставленные задачи}
% \begin{enumerate}
%   \item Разработать метод межпроцедурного анализа программ, пригодный для анализа крупных программных проектов, а также расширяемый на различные виды проверок
%   \item Разработать метод межмодульного анализа программ, разработанных с использованием языков C и C++
%   \item Разработать метод отображения результатов анализа при использовании предложенного метода межпроцедурного анализа
%   \item Для экспериментального подтверждения эффективности предложенных методов реализовать их и осуществить тестирование разработанных методов на реальных программных проектах
%   \item По результатам тестирования сделать выводы о пригодности разработанного метода, о его применимости для анализа крупных программных комплексов и качестве анализа кода программ
% \end{enumerate}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Основные положения, выносимые на защиту}
% \begin{enumerate}
%   \item Новая модификация метода межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, разработанных с использованием языков C и C++
%   \item Метод межмодульного анализа программ, разработанных с использованием языков C и C++, архитектура анализатора, эвристики, связанные с объединением синтаксических деревьев различных единиц трансляции
%   \item Метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
% \end{enumerate}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Мотивация}
% \begin{itemize}
%   \item Необходимость автоматизации поиска дефектов в крупных и критичных по качеству программных продуктах требует выполнения анализа с высокой полнотой и точностью
%   \item При использовании метода символьного выполнения можно достичь указанных характеристик
%   \begin{itemize}
%     \item Анализ, чувствительный к пути выполнения и потоку управления
%   \end{itemize}
% 
%   \item Для данного метода существует проблема экспоненциального роста количества путей при увеличении размера программы
%   \item Межпроцедурный анализ усугубляет данную проблему, увеличивая количество возможных путей выполнения при использовании контекстно-чувствительного анализа
%   \item Задача разработки метода МПА, в меньшей степени затронутого данной проблемой, является актуальной.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Мотивация~--- языки программирования C и C++}
% \begin{itemize}
%   \item Большое количеством видов потенциальных ошибок, которые может допустить программист
%   \begin{itemize}
%     \item Неправильная работа с~указателями
%     \item Неопределённое или зависящее от реализации поведение
%   \end{itemize}
%   \item Наиболее распространённые и~известные языки
%     \begin{itemize}
%     \item Большое количество существующего системного и~прикладного ПО
%     \item ПО с высокими требованиями к производительности
%     \item Низкоуровневые компоненты, такие как компоненты операционных систем и~драйверы
%   \end{itemize}
%   \item Проблема глубокого анализа программ на языках C и C++ является актуальной.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Предлагаемая модификация метода резюме}
% \begin{itemize}
%   \item Анализ функции вне контекста вызова с последующим уточнением контекста
%   \item Позволяет не анализировать одну и ту же функцию многократно, а использовать её резюме
%   \item Использовался различными исследователями для реализации обособленных видов проверок
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Предлагаемая модификация метода резюме}
% \begin{itemize}
%   \item Цель исследования: построение многоцелевого анализатора для языков C и C++
%   \item Решённые проблемы:
%   \begin{itemize}
%     \item Поддержка модели памяти C/C++, включая арифметику указателей, наследования и выравнивания полей структур
%     \item Отсечение недостижимых путей выполнения
%     \item Поддержка сложных алгоритмов поиска дефектов и их одновременного использования при МПА методом резюме
%   \end{itemize}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Структура резюме}
% \begin{itemize}
%   \item В предлагаемой модификации, \textit{резюме} представляет собой набор \textit{ветвей резюме}, каждая из которых соответствует листу графа выполнения функции
%   \item Соответственно, каждая ветвь задаёт класс эквивалентности относительно параметров функции
%   \item Каждая ветвь содержит предусловия, при которых достижима данная ветвь, и постусловие, которое является эффектом ветви выполнения функции на состояние программы.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Поддержка модели памяти в резюме}
% \begin{itemize}
%   \item Для анализа функции в контексте вызова производится \textit{актуализация} символьных значений
%   \begin{enumerate}
%     \item Вне контекста строится цепочка доступа вида \\ \textit{<<параметр функции 1 $\rightarrow$ поле lock $\rightarrow$ элемент 2>>}
%     \item В контексте вызова цепочка доступа применяется к региону памяти, являющемуся фактическим аргументом при вызове функции
%   \end{enumerate}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Применение резюме. Отсечение недостижимых путей}
% \begin{itemize}
%   \item Каждое символьное значение имеет своё множество возможных конкретных значений
%   \item Пересечение этих диапазонов для фактических и формальных параметров становится новым диапазоном конкретных значений фактического параметра в вызывающей функции
%   \item Пустое пересечение означает недостижимость данной ветви выполнения
%   \item Если ветвь выполнения достижима, применяются постусловия, включающие в себя привязку новых символьных значений к регионам памяти, в которые произошла запись в вызываемой функции
%   \item Символьное значение, возвращаемое функцией, также подвергается актуализации и становится значением выражения-вызова функции.
% \end{itemize}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Проверки при применении резюме}
% \begin{itemize}
%   \item Каждый проверяющий модуль имеет своё состояние (type state)
%   \item Каждый проверяющий модуль может создавать своё резюме и применять его независимо как от других модулей, так и от остальных компонентов анализатора, что позволяет реализовывать МПА методом резюме для проверок произвольного вида
%   \item В резюме проверяющего модуля обычно входят изменения состояния программы и отложенные проверки
%   \item В рамках данной работы МПА методом резюме был реализован для проверяющих модулей различного назначения:
%     \begin{itemize}
%     \item Строковое переполнение
%     \item Корректность операций над файловыми дескрипторами
%     \item Проверка корректности синхронизации в многопоточной среде
%     \item Целочисленное переполнение
%     \item Запись в переменную константного типа
%   \end{itemize}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Построение отчёта}
% \begin{itemize}
%   \item Отчёт должен содержать полную информацию о пути выполнения, на котором наблюдается дефект
%   \item При использовании метода резюме происходит потеря информации о пути выполнения внутри вызываемой функции
%   \item Для решения этой проблемы предлагается использовать хранение ссылки на узел графа вызываемой функции, соответствующий ветви применения резюме.
% \end{itemize}
% \end{frame}

% \begin{frame}
% \frametitle{Межмодульный анализ}
% \begin{itemize}
%   \item C и C++~--- языки с поддержкой раздельной компиляции
%   \item Для анализа крупных программ необходимо обрабатывать функции, определённые в различных единицах трансляции
%   \item Для решения этой проблемы предлагается использовать слияние синтаксических деревьев единиц трансляции.
%     \begin{itemize}
%       \item Данный метод позволяет сохранять всю доступную информацию о программе без потери при преобразованиях
%     \end{itemize}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Межмодульный анализ~--- реализация}
% В данной работе реализован межмодульный анализ, состоящий из трёх фаз
% \begin{enumerate}
%   \item На первой фазе происходит перехват команд построения проекта
%   \begin{enumerate}
%     \item Построение синтаксических деревьев единиц трансляции с сохранением их на носитель
%     \item Сохранение данных о требуемых и имеющихся определениях функций
%   \end{enumerate}
%   \item На второй фазе строится соответствие между требуемыми и имеющимися функциями, производится топологическая сортировка графа вызовов
%   \item На третьей фазе происходит запуск анализа со слиянием синтаксических деревьев.
% \end{enumerate}
% \end{frame}
% 
% \begin{frame}[allowframebreaks]
% \frametitle{Межмодульный анализ~--- решаемые проблемы}
% \begin{enumerate}
%   \item Необходимость различения синтаксических деревьев и функций различных архитектур, а также перегруженных функций
%     \begin{itemize}
%       \item Для поиска используются сигнатуры, содержащие соответствующую информацию
%     \end{itemize}
%   \item Длительный рекурсивный поиск
%   \begin{enumerate}
%     \item Объявления с различными именами являются различными
%     \item Объявления различных разновидностей являются различными
%     \item Объявления из одного файла с одинаковыми текстовыми позициями начала и завершения считаются совпадающими
%   \end{enumerate}
%   \item Сложные зависимости между импортируемыми объявлениями при рекурсивном импорте
%     \begin{itemize}
%       \item Необходимо переупорядочивать сливаемые объявления
%     \end{itemize}
% \end{enumerate}
% \end{frame}

% 
% \begin{frame}
% \frametitle{Покрытие~--- внутримодульный анализ}
% \begin{figure}[h]
%   \center{\includegraphics[width=0.8\linewidth]{../Dissertation/images/single-nodes.pdf}}
% \end{figure}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Покрытие~--- межмодульный анализ}
% \begin{figure}[h]
%   \center{\includegraphics[width=0.8\linewidth]{../Dissertation/images/xtu-nodes.pdf}}
% \end{figure}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Поиск дефектов~--- внутримодульный анализ}
% \begin{figure}[h]
%   \center{\includegraphics[width=0.8\linewidth]{../Dissertation/images/single-unique.pdf}}
% \end{figure}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Поиск дефектов~--- межмодульный анализ}
% \begin{figure}[h]
%   \center{\includegraphics[width=0.8\linewidth]{../Dissertation/images/xtu-unique.pdf}}
% \end{figure}
% \end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Алгоритм применения резюме}
\begin{figure}[h]
  \center{\includegraphics[width=1\linewidth]{images/applyscheme.png}}
\end{figure}
\end{frame}
%--------------------------------------------------------------------------------------------------------

\begin{frame}[allowframebreaks]
\frametitle{Научные результаты, представляемые на защиту}
\begin{enumerate}
  \item Продемонстрирован значительный рост производительности анализа
  \item Покрытие операторов программы увеличилось в 10--15 раз
  \item Скорость поиска дефектов также увеличилась: то же количество уникальных дефектов можно обнаружить в 2--3 раза быстрее
  \item Точность анализа сохранилась и составила от 80\% до 84\%
\end{enumerate}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Перспективы развития методов и ПО, разработанного на их основе}
\begin{itemize}
  \item Исследование и реализация возможностей повторного использования резюме при межмодульном анализе с целью увеличения быстродействия процесса анализа
  \item Использование методов, применяемых компоновщиками, для поиска требуемых определений функций с целью улучшения корректности межмодульного анализа в рамках разработанного ПО
  \item Реализация МПА методом резюме для большего количества проверяющих модулей, включая проверки безопасности, с целью дальнейшего внедрения и промышленного применения результирующего ПО. 
\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Результаты работы}
\begin{itemize}
  \item Разработана новая модификация метода межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, реализованных с использованием языков C и C++. Данный метод анализа позволяет производить анализ с высоким качеством и полнотой, однако имеет экспоненциальную сложность, связанную с проблемой роста количества путей с увеличением объёма программы (path explosion), что делает задачу улучшения его производительности особенно актуальной. Важными особенностями разработанного метода является поддержка проверок произвольного вида и их одновременного выполнения, а также поддержка модели памяти, используемой в языках C и C++, в том числе, с учётом арифметики указателей, наследования и выравнивания полей структур.
  \item Разработан метод межмодульного анализа программ, реализованных с использованием языков C и C++ для статического анализатора, использующего в качестве входных данных непосредственно исходный код программы. Использование промежуточного представления в виде синтаксического дерева программы позволяет производить анализ без потери информации о программе.
  \item Разработан метод построения отчёта о дефекте при использовании предложенной модификации метода резюме для метода символьного выполнения. Данный метод позволяет строить информативный межпроцедурный отчёт, включающий показ переходов, выполнимых условий и представляющих интерес событий в процессе выполнения программы.
  \item Для экспериментального подтверждения эффективности предложенных методов они были реализованы их для использования в приложении-анализаторе (Clang Static Analyzer, анализатор с открытым исходным кодом). Было осуществлено тестирование разработанных методов на реальных программных проектах~--- пакетах пользовательского окружения ОС Android.
  \item По результатам тестирования сделан выводы о пригодности разработанного метода. Несмотря на сохранение экспоненциальной сложности анализа, тесты показали, что скорость поиска дефектов и покрытие путей тестируемых программы увеличились, а качество анализа кода программ сохранилось на том же уровне.
\end{itemize}
\end{frame}

%--------------------------------------------------------------------------------------------------------
%TODO: Убрать за ``Спасибо'', сделать запасным.
\begin{frame}[allowframebreaks]
\frametitle{Решаемые задачи}

\begin{enumerate}
  \item Исследование областей применения и функциональных особенностей систем статического анализа кодов программ для формализации подхода к модификации метода с целью уменьшения времени анализа.
  \item Разработка модификации метода межпроцедурного анализа программ, пригодной для реализации в многоцелевом статическом анализаторе программного кода на языках C и C++ и позволяющей использовать различные виды проверок кода с целью поиска дефектов.
  \item Теоретическое обоснование возможности применения разрабатываемой модификации метода для применения в автоматизированной системе тестирования.
  \item Разработка математической модели для оценки корректности применения разработанного подхода к анализу программ.
  \item Разработка метода межмодульного анализа программ, разработанных с использованием языков C и C++, для повышения полноты анализа многокомпонентных систем.
  \item Разработка метода отображения результатов анализа при использовании предложенного метода межпроцедурного анализа с целью уменьшения времени на воспроизведение и исправление обнаруженных дефектов.
  \item Реализация предложенных методов для использования в приложении-анализаторе (Clang Static Analyzer, анализатор с открытым исходным кодом) с целью экспериментального подтверждения их эффективности и тестирование разработанных методов на реальных программных проектах~--- пакетах пользовательского окружения ОС Android.
\end{enumerate}

\end{frame}
%--------------------------------------------------------------------------------------------------------

% \begin{frame}
% \frametitle{Формулы}
% $$
% \left\{
%   \begin{array}{rl}
%     \dot x = & \sigma (y-x) \\
%     \dot y = & x (r - z) - y \\
%     \dot z = & xy - bz
%   \end{array}
% \right.
% $$
% \end{frame}
% 
% \begin{frame}
% \frametitle{Составное изображение}
% \begin{figure}[h]
%   \begin{minipage}[h]{0.49\linewidth}
%     \textbf{Составная \\ подпись 1}
%     \center{\includegraphics[width=1\linewidth]{knuth1}}
%   \end{minipage}
%   \hfill
%   \begin{minipage}[h]{0.49\linewidth}
%     \textbf{Составная \\ подпись 2}
%     \center{\includegraphics[width=1\linewidth]{knuth2}}
%   \end{minipage}
% \end{figure}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Таблица}
% \begin{tabular}{|l|l|}
% \hline
% \textbf{Заголовок 1} & \textbf{Заголовок 2} \\
% \hline
% Сумма & $b+a$ \\
% \hline
% Разность & $a-b$ \\
% \hline
% Произведение & $a*b$ \\
% \hline
% \end{tabular}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Большой многоуровневый список}
% \begin{itemize}
%   \item \textbf{Пункт 1}
%     \begin{itemize}
%       \itemi Подпункт 1-1
%       \itemi Подпункт 1-2
%     \end{itemize}
%   \item \textbf{Пункт 2}
%     \begin{itemize}
%       \itemi Подпункт 2-1
%     \end{itemize}
%   \item \textbf{Пункт 3}
%     \begin{itemize}
%       \itemi Подпункт 3-1
%       \itemi Подпункт 3-2
%     \end{itemize}
%   \item \textbf{Пункт 4}
%     \begin{itemize}
%       \itemi Подпункт 4-1
%     \end{itemize}
%   \item \textbf{Пункт 5}
%     \begin{itemize}
%       \itemi Подпункт 5-1
%       \itemi Подпункт 5-2
%       \itemi Подпункт 5-3
%     \end{itemize}
% \end{itemize}
% \end{frame}
% 
% \begin{frame}
% \frametitle{Четыре изображения}
% \begin{figure}[H]
%   \center
%     \includegraphics[width=0.4\linewidth]{latex}
%     \includegraphics[width=0.4\linewidth]{latex}\\
%     \includegraphics[width=0.4\linewidth]{latex}
%     \includegraphics[width=0.4\linewidth]{latex}
% \end{figure}
% \end{frame}


\end{document} 