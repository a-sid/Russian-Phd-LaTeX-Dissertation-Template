\chapter*{Введение}							% Заголовок
\addcontentsline{toc}{chapter}{Введение}	% Добавляем его в оглавление

\newcommand{\actuality}{}
\newcommand{\aim}{\textbf{Целью}}
\newcommand{\tasks}{задачи}
\newcommand{\defpositions}{\textbf{Основные положения, выносимые на~защиту:}}
\newcommand{\novelty}{\textbf{Научная новизна:}}
\newcommand{\influence}{\textbf{Научная и практическая значимость}}
\newcommand{\reliability}{\textbf{Степень достоверности}}
\newcommand{\probation}{\textbf{Апробация работы.}}
\newcommand{\contribution}{\textbf{Личный вклад.}}
\newcommand{\publications}{\textbf{Публикации.}}

\input{../common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам
\section*{Актуальность работы}
Для~больших и~сложных программно-технических комплексов полное покрытие всех путей выполнения программы становится невозможным, поскольку эта задача соотносится с проблемой останова. Ресурсы, выделенные на~тестирование сложных программных комплексов, всегда ограничены, что приводит к~необходимости рационального  их использования. Проблема поиска подходящего компромисса  между повышением надежности разрабатываемых программных средств и~эффективным использованием ресурсов становится все актуальнее. Для~обеспечения надёжности программных средств  активно ведётся разработка новых эффективных методов и~средств автоматического тестирования, позволяющих за~реальное время предупредить и~выявить как~можно большее количество дефектов в~программе. В~настоящее время всё большее распространение получают инструменты, предназначенные для~поиска дефектов в~программном коде.

Обычно различают статический, динамический и~смешанный анализ. Под статическим анализом понимают анализ программы, не~требующий её непосредственного выполнения. Часть инструментов, таких, как~Clang Static Analyzer \cite{csa}, PVS-Studio \cite{pvs}, Cppcheck \cite{cppcheck}, Lint \cite{lint}, исследует непосредственно код программы или структуры данные, строящиеся на~его основе,~--- абстрактное синтаксическое дерево или граф потока управления. Другая часть инструментов статического анализа использует для~анализа более низкоуровневое представление программы~--- скомпилированный объектный или промежуточный код (Coverity Prevent \cite{coverity}, Svace \cite{svace}, FindBugs \cite{findbugs}). В~отличие от~статического анализа, для~динамического анализа программы требуется её выполнение~--- на~специальных входных данных, в~виртуальной машине (Valgrind \cite{valgrind}), с~использованием инструментации (AddressSanitizer \cite{asan}, ThreadSanitizer \cite{tsan}, UndefinedBehaviorSanitizer), с~использованием дополнительных библиотек или их подменой. Наконец, смешанный анализ представляет собой комбинацию статического и~динамического анализа и~используется в~таких инструментах как~Mayhem \cite{mayhem}, KLEE \cite{klee}, а~также других автоматических генераторов контрпримеров.

Перечисленные виды анализа имеют свои достоинства и~недостатки, в~частности, различные виды анализа наиболее эффективны для~поиска различных видов ошибок.

\begin{itemize}
 \item Динамический анализ наиболее хорошо зарекомендовал себя для~поиска ошибок, связанных с~многопоточностью и~управлением памятью, однако крайне затратен в~случае больших проектов. Значительным недостатком динамического анализа является необходимость явного выполнения программы, что влечёт за~собой необходимость подготовки входных данных (или их автогенерации), и~быстрый рост длительности такого анализа с~увеличением объёма проекта. Это также затрудняет интеграцию инструментов, использующих динамический анализ, в~процесс разработки, что снижает шансы быстрого обнаружения ошибки.
 \item Статический анализ позволяет эффективно производить поиск различных видов дефектов: опечаток, некорректного использования типов, проблем безопасности, неопределённого или недокументированного поведения и~многих других видов. Инструменты для~выполнения статического анализа могут быть легко интегрированы в~процесс разработки. При~этом они могут быть использованы как~индивидуальные вспомогательные инструменты разработки (например, для~подсветки кода, содержащего потенциальную ошибку), так и~в~качестве инструментов, использующихся группой разработчиков (например, для~развёртывания и~интеграции в~систему непрерывной сборки). Сравнительно небольшое время, затрачиваемое на~анализ, вкупе с~интеграцией в~рабочий процесс позволяет быстро находить дефекты в~разрабатываемых программах. Недостатком статических анализаторов является возможность выдачи ими некорректных сообщений об ошибках~--- ложных срабатываний (ошибок первого рода) и~возможность пропуска имеющихся дефектов (ошибки второго рода), вероятность которых стараются снизить при~разработке анализаторов. Вред от~ошибок второго рода очевиден, но и~ошибки второго рода играют не~меньшую роль при~оценке качества анализатора, поскольку их большое количество отвлекает разработчика на~длительное время для~просмотра ложных срабатываний, поэтому при~большом количестве ложных срабатываний инструмент может стать практически непригодным для~использования. Однако при~небольшом количестве ложных срабатываний польза от~применения анализатора в~виде снижения времени, затрачиваемого на~обнаружение ошибки, быстро перевешивает недостаток в~виде времени, затрачиваемого на~просмотр ложных срабатываний.
\end{itemize}

Первоначально распространение у разработчиков получили инструменты, использующие методы на~основе анализа синтаксического дерева программы и~её графа потока управления. Преимуществами данных методов анализа программного кода являются:

\begin{itemize}
 \item высокая скорость работы,
 \item незначительное потребление памяти,
 \item возможность его реализации в~компиляторе для~выполнения дополнительных проверок и~предупреждения программиста о~потенциально некорректном поведении компилируемого кода. Это становится возможным благодаря малому потреблению системных ресурсов, позволяющему лишь незначительно снижать производительность компилятора,
 \item возможность интеграции в~среды разработки для~осуществления анализа <<на лету>>, непосредственно в~процессе набора кода программистом, или в~качестве дополнительного инструмента для~быстрого обнаружения дефекта.
\end{itemize}

Аналогичные методы применяются в~компиляторах для~предупреждения программиста о~потенциально некорректном поведении программы, поскольку и~синтаксическое дерево, и~граф потока управления являются основными структурами данных, с~которыми работает компилятор. Однако проверка, включаемая в~состав компилятора, должна исключать возможность ложных срабатываний, т.~е. являться консервативной. Инструменты же статического анализа могут включать также и~неконсервативные проверки, с~возможностью выдачи ложных срабатываний.

Данные методы могут обнаруживать лишь очень узкие классы дефектов в~программном коде: простые ошибки, затрагивающие лишь несколько операторов, расположенных в~пределах одной функции. Это может быть простейший поиск использования неинициализированных переменных, ошибок при~преобразовании типов, потенциально лишние операции, а~также другие дефекты, для~поиска которых не~требуется анализировать циклы и~условные переходы. При~наличии циклов и~переходов в~анализируемой функции эффективность видов анализа, нечувствительных к~путям выполнения, резко падает, поскольку данные методы позволяют корректно определить достижимость одних операторов из других операторов при~выполнении программы лишь в~тривиальных случаях.

Значительно более ресурсоёмким, но и~более подробным является анализ на~основе обхода путей выполнения программы. Основы этих методов были заложены ещё в~70-х~годах. Метод символьного выполнения был предложен Джеймсом Кингом в~1976 году \cite{king76}. В~основе метода лежит идея разбиения входных данных на~классы эквивалентности в~зависимости от~встречаемых по пути выполнения условий. Метод абстрактной интерпретации, предложенный в~1977~году супругами Кузо \cite{cousot}, предполагает использовать абстрагирование данных и~их анализ на~основе алгебры решёток. Однако данные походы стали получать распространение только в~последнее время. Это связано с~увеличившейся мощностью компьютеров: время анализа растёт пропорционально количеству путей выполнения, что означает экспоненциальный рост времени анализа с~увеличением размера программы. (Вообще говоря, абсолютно полный и~точный анализ программы невозможен в~связи с~проблемой останова, независимо от~применяемого подхода.) В~отличие от~базового анализа графа потока управления, анализ путей выполнения способен учитывать условия выполнения тех или иных ветвей программы,  следствием чего являются преимущества данного вида анализа~--- его более высокая точность и~способность покрыть намного больший класс дефектов. Такие методы, как~абстрактная интерпретация и~символьное выполнение, нашли применения в~известных инструментах для~поиска дефектов, например, Coverity SAVE, Clang Static Analyzer и~многих других.

Одними из наиболее актуальных целевых языков для~статического анализа традиционно являются языки C и~C++. Причин для~этого несколько. Во-первых, это связано с~большим количеством видов потенциальных ошибок, которые может допустить программист, ведущий разработку с~использованием этих языков. Наиболее специфичными среди таких ошибок являются ошибки, связанные с~неправильной работой с~указателями~--- переполнение буфера, обращение к~неинициализированной памяти или к~памяти по некорректному адресу. Во-вторых, стандарты языков трактуют достаточно большое количество ситуаций как~не~имеющих определённого поведения (например, порядок вычисления аргументов функций может быть произвольным), что, с~одной стороны, позволяет компилятору проводить более глубокие оптимизации и~получить наибольшую скорость выполнения результирующего кода, но, с~другой стороны, требует от~программиста повышенного внимания в~процессе написания кода программы для~учёта этих особенностей. В-третьих, эти языки являются одними из самых распространённых и~известных, с~их использованием было разработано и~продолжает создаваться большое количество как~системного, так и~прикладного программного обеспечения. Кроме того, язык C является практически единственным выбором при~разработке низкоуровневых компонентов, например, компонентов операционных систем и~драйверов, что также предъявляет повышенные требования к~качеству программного кода.

\textbf{Целью диссертационной работы} является разработка метода межпроцедурного межмодульного анализа крупных программных комплексов, разработанных с использованием языков C и C++, способного осуществлять анализ проектов масштаба ОС Android и OS Tizen за приемлемое время и обеспечивающего достаточное покрытие путей выполнения программы.

Для~достижения поставленной цели необходимо было решить следующие задачи:
\begin{enumerate}
  \item Разработать метод межпроцедурного анализа программ с высокой масштабируемостью, пригодный для анализа крупных программных проектов, а также расширяемый на различные классы проверок
  \item Разработать метод межмодульного анализа программ, разработанных с использованием языков C и C++
  \item Разработать метод отображения результатов анализа при использовании разработанного метода межпроцедурного анализа
  \item Реализовать разработанные методы с использованием инфраструктуры статического анализатора Clang Static Analyzer
  \item Осуществить проверку разработанных методов на реальных программных проектах
  \item Провести анализ разработанного метода на предмет масштабируемости и качества анализа с учётом результатов, полученных при проверке реальных программных проектов.
\end{enumerate}

\textbf{Научная новизна}

В работе получены следующие результаты, обладающие научной новизной:
\begin{enumerate}
  \item Разработан и подробно описан метод межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, разработанных с использованием языков C и C++
  \item Разработан и подробно описан метод межмодульного анализа программ, разработанных с использованием языков C и C++ для статического анализатора, использующего в качестве входных данных непосредственно исходный код программы
  \item Разработан метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
  \item Вышеперечисленные методы реализованы с использованием инфраструктуры статического анализатора Clang Static Analyzer и апробированы на реальных проектах (ОС Android)
\end{enumerate}

\textbf{Научная и практическая значимость}

Предложена новая модификация метода межпроцедурного 

\textbf{На защиту выносятся следующие основные положения:}
\begin{enumerate}
  \item Метод межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, разработанных с использованием языков C и C++
  \item Метод межмодульного анализа программ, разработанных с использованием языков C и C++, архитектура анализатора, эвристики, связанные с объединением синтаксических деревьев различных модулей трансляции
  \item Метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
\end{enumerate}

%\textbf{Степень достоверности} полученных результатов обеспечивается \ldots Результаты находятся в соответствии с результатами, полученными другими авторами.

\textbf{Апробация работы}

Основные результаты работы докладывались~на:
перечисление основных конференций, симпозиумов и~т.\:п.

%\textbf{Личный вклад.} Автор принимал активное участие \ldots

\textbf{Публикации.} Основные результаты по теме диссертации изложены в \todo{4 печатных изданиях}~\cite{Sokolov,Gaidaenko,Lermontov,Management},
3 из которых изданы в \todo{журналах, рекомендованных ВАК}~\cite{Sokolov,Gaidaenko}, 
1 --- \todo{в тезисах докладов}~\cite{Lermontov,Management}.

%% регистрируем счётчики в системе totcounter
\regtotcounter{totalcount@figure}
\regtotcounter{totalcount@table}       % Если поставить в преамбуле то ошибка в числе таблиц
\regtotcounter{TotPages}               % Если поставить в преамбуле то ошибка в числе страниц

\textbf{Объем и структура работы.} Диссертация состоит из~введения, четырёх глав, заключения и~двух приложений.
%% на случай ошибок оставляю исходный кусок на месте, закомментированным
%Полный объём диссертации составляет  \ref*{TotPages}~страницу с~\totalfigures{}~рисунками и~\totaltables{}~таблицами. Список литературы содержит \total{citenum}~наименований.
%
Полный объём диссертации составляет \formbytotal{TotPages}{страниц}{у}{ы}{} 
с~\formbytotal{totalcount@figure}{рисунк}{ом}{ами}{ами}
и~\formbytotal{totalcount@table}{таблиц}{ей}{ами}{ами}. Список литературы содержит  
\formbytotal{citenum}{наименован}{ие}{ия}{ий}.
