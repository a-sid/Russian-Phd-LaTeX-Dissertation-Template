\chapter{Методы статического межпроцедурного анализа программ} \label{chapt1}


\section{Используемая терминология}

Целью анализа кода программы является определение наличия в нём \textit{дефектов}. В широком смысле под дефектом понимается \todo{определение из умной книги, например, Липаев, но вообще это нарушение требований качества}. Анализаторы обычно оперируют более узким понятием дефекта, понимая его как описанный класс свойств программного кода, приводящих к нарушению требований к качеству программе. Данное определение подразумевает описание свойства программы, которое необходимо анализатору для поиска дефекта. Для многих видов дефектов, встречаемых при разработке программ, существуют описания и классификация. Наиболее известными среди них являются каталоги Common Weaknesses Enumeration (CWE) \cite{cwe}, Security Emergency Readiness Team (CERT) \cite{cert-org}, Motor Industry Software Reliability Association (MISRA) \cite{???}. Существуют также отраслевые и проектные стандарты, включающие список возможных нарушений, такие как JSF C++ Coding Standards \ref{jsf}.

Поскольку автоматизированный поиск дефектов производится с использованием формальных методов, для поиска дефектов обычно недостаточно описания. На основе описания класса дефектов строится \textit{критерий дефектности}~--- формальное описание класса дефекта или его подмножества, позволяющее производить автоматический поиск. Для автоматизации поиска используется программа, называемая \textit{анализатором}. Критерий дефектности обычно формулируется в терминах textit{модели анализатора}~--- описания анализатора и его принципа работы, учитывающего особенности его реализации. Задачей анализатора обычно является построение внутренних структур данных на основе кода программы, проверка полученных структур на соответствие заданному критерию дефектности и выдача диагностических сообщений в случае обнаружения соответствия.

Срабатывания анализатора и отсутствие срабатывания можно разделить на корректные и ложные. Срабатывание анализатора является \textit{корректным (true positive, TP)}, если отчёт анализатора указывает на действительно присутствующий в коде программы дефект. Срабатывание анализатора является \textit{ложным (false positive, FP)}, если программный код на самом деле не содержит дефекта, указанного в отчёте анализатора. Отсутствие срабатывание анализатора является \textit{корректным (true negative, TN)}, если программный код, на котором анализатор не выдал диагностическое сообщение, действительно является корректным. Отсутствие срабатывание анализатора является \textit{некорректным (false negative, FN)}, или \textit{пропуском}, если анализатор не выдал диагностическое сообщение при анализе программного кода, содержащего дефект.

Ряд срабатываний анализатора являются положительными с точки зрения соответствия правилу поиска, однако по-каким либо причинам код невозможно изменить так, чтобы он соответствовал правилу кодирования. Такая ситуация может возникнуть, например, при необходимости поддерживать стандартизированный программный интерфейс (например, JNI~--- Java Native Interface, Posix-функции). Такие срабатывания принято классифицировать отдельной категорией~--- \textit{\todo{придумать перевод} Intentional}.

В силу различных ограничений анализатору недоступна вся возможная информация о программе и её окружении. Многие анализаторы производят анализ программы по частям, что дополнительно уменьшает объём доступной анализатору информации. Кроме того, структуры данных анализатора зачастую строятся с упрощением В результате 


% Здесь написать об абстрактной интерпретации (см. книгу драконов).

\section{Метод анализа программ с помощью символьного выполнения} \label{sect1_1}
В данной работе исследуется метод символьного выполнения \cite{king76}, применяемый для анализа путей выполнения программ. Этот метод подразумевает абстрактное движение по путям программы, имитирующее её выполнение в~зависимости от~входных данных, сопровождающееся изменением состояния программы в~различных точках. Суть метода символьного выполнения заключается в~разбиении множества входных данных на~классы эквивалентности, что позволяет оперировать при~анализе не~отдельными входными значениями (число которых может быть очень большим и~экспоненциально растёт в~зависимости от~количества входных аргументов) и~их перебором, а~целыми классами эквивалентности, число которых может оказаться и~не конечным, но не~превышает общее количество комбинаций отдельных входных значений. Однако, как~правило, количество классов эквивалентности комбинаций входных данных оказывается значительно ниже числа всех возможных комбинаций входных данных, что резко увеличивает возможности анализатора по обработке путей выполнения.

Основной алгоритм символического выполнения \cite{king76} заключается в~следующем.
\begin{enumerate}
 \item При~старте анализа функции входные значения её аргументов и~внешних по отношению к~ней переменных неизвестны, т.~е. они потенциально могут принимать любые значения. Начальное состояние является корневым узлом специального графа~--- дерева выполнения программы.
 \item Каждой неизвестной величине назначается абстрактное значение, называемое символьным значением.
 \item Обработка операторов языка изменяет значения переменных программы, т.~е. их символьные значения. Считается, что над символьными значениями уже определён необходимый набор операций для~вычисления новых символьных значений на~основе уже имеющихся. Выполнение каждого оператора добавляет узел к~дереву выполнения программы с~входящим ребром от~предыдущего оператора.
 \item При~обработке условных операторов в~дерево выполнения программы добавляется не~один, а~два узла: в~первом узле условие выполняется, во втором~--- нет. Совокупность условий, при~которых достижим данный узел графа выполнения программы, определяет класс эквивалентности входных данных программы или функции. Таким образом, каждый лист дерева выполнения программы соответствует классу эквивалентности входных данных, которая приводит программу в~конечное состояние, обозначаемое данным листом. 
 \item Обычно каждое из условий, определяющих класс эквивалентности входных данных, можно представить в~виде уравнения или неравенства. В~результате наложения на~путь выполнения программы нескольких условий в~соответствие каждому классу эквивалентности входных данных ставится система уравнений или неравенств. Решениями этих систем уравнений являются множества реальных значений входных величин, при~которых будут выполнены ветви выполнения программы. Если система является несовместной, т.~е. не~имеет ни~одного решения, то путь выполнения, соответствующий этой системе, недостижим.
 \item Анализатор производит обход всех путей получившегося дерева выполнения с~целью поиска ситуаций, которые могли бы трактоваться как~некорректное поведение. В~случае обнаружения такой ситуации анализатор сообщает о~дефекте и~при этом указывает набор условий, при~выполнении которых программа проявит некорректное поведение.
\end{enumerate}

Данный алгоритм можно рассмотреть на~следующем примере. Пусть имеется следующая программа чтения из файла на~языке C:

\begin{verbatim}
     1  int test(int a, int b) {
     2    FILE *f = fopen("file.txt");
     3    int result;
     4    fscanf(f, "%d", &result);
     5    fclose(f);
     6    if (a == 0 && b > 2) {
     7      fclose(f);
     8      return 0;
     9    }
    10    return result;
    11  }
\end{verbatim}

В~результате выполнения этой программы будут достижимы три конечных состояния с~уравнениями $a \neq 0, b \in [INT\_MIN, INT\_MAX]$; $a = 0, b \leqslant 2$; $a = 0, b > 2$. Соответствующий граф представлен на~рис.~\ref{pic:sample-exec}.

\begin{figure}
   \centering
   \includegraphics[width=0.9\linewidth]{article-1-symexec-sample.pdf}
   \caption{Граф выполнения программы чтения из файла}\label{pic:sample-exec}
\end{figure}

В~результате получены три пути с~соответствующими ограничениями. Теперь анализатор просматривает каждый из этих путей и~обнаруживает дефект: на~одном из путей файл \texttt{f} закрывается дважды, что приводит к~неопределённому поведению. Этому пути соответствует система $a = 0, b > 2$. Таким образом дефекту сопоставляется множество условий, при~котором он проявляется при~выполнении программы.

Основным преимуществом метода символьного выполнения является простота и~очевидность концепции, на~которой он основан: метод использует идею <<симуляции>> выполнения программы, так, как~это делает программист. Метод символьного выполнения получил распространение не~только в~инструментах статического, но и~смешанного анализа: так, хорошо зарекомендовали себя инструменты, использующие подход concolic testing \cite{concolic}  (символьно-конкретное~--- concrete+symbolic). Concolic testing~--- это метод поиска дефектов, осуществляющий генерацию тестовых данные, при~использовании которых программа проявляет некорректное поведение, на~основе символьного выполнения.

Наряду с~преимуществами, метод имеет ряд недостатков. Так, существует проблема экспоненциального роста количества проходимых путей (path explosion), приводящая к~проблемам с~масштабируемостью метода. Есть также проблемы при~моделировании циклов, поскольку зачастую количество итераций цикла точно неизвестно~--- оно также является символьной величиной. Тем не~менее, метод символьного выполнения активно применяется, в~том числе, целым набором широко используемых инструментов анализа программ. Таким образом, разработка подходов для~улучшения данного метода является актуальной и~практически важной задачей.

Основные проблемы масштабируемости метода связаны с~двумя факторами.
\begin{enumerate}
 \item При~моделировании циклов время анализа линейно зависит от~количества итераций, проходимых программой при~выполнении цикла. Даже если число итераций известно, но велико, анализ программы выполняется длительное время, резко возрастающее при~наличии в~программе вложенных циклов. При~использовании смешанного анализа обычно эту проблему анализом выполнения программы для~установления реального количества итераций. При~статическом анализе наиболее распространённым решением является ограничение количества итераций циклов каким-либо максимальным константным значением. Этот подход позволяет ограничить время анализа, однако не~решает проблему роста времени анализа при~наличии вложенных циклов. Кроме того, это ограничение приводит к~потере точности моделирования, что, в~свою очередь, приводит к~ложным срабатываниям или отсутствию срабатываний в~тех случаях, когда они ожидаются.
 \item Время анализа быстро растёт при~использовании межпроцедурного анализа.
\end{enumerate}

Отличие межпроцедурного анализа (МПА) от~внутрипроцедурного (ВПА) заключается в~том, что анализатор позволяет использовать доступные определения пользовательских функций для~моделирования эффектов их вызовов. МПА используется для~решения двух основных проблем, связанных с~использованием внутрипроцедурного анализа. Во-первых, межпроцедурный анализ позволяет определить эффект, оказываемый на~состояние программы в~результате вызова из анализируемой функции другой функции. В~отсутствие межпроцедурного анализа вызов функции можно моделировать либо самостоятельно (с помощью спецификаций эффектов), либо приближённо. Первый подход, как~правило, используется для~функций, эффекты которых специфицированы. Таковы, например, функции различных публичных интерфейсов взаимодействия. Наиболее распространено такое моделирование для~Posix API, встречаются также реализации, моделирующие вызовы Windows API. Кроме того, хорошими кандидатами на~специфицирование являются функции, принадлежащие стандартной библиотеке языка, поскольку она, как~правило, стандартизирована, реже~--- функции других распространённых библиотек (например, STL и~др.).

Во-вторых, в~случае, если полная спецификация функции недоступна, при~внутрипроцедурном анализе может использоваться приближённое моделирование. В~этом случае считается, что вызов функции может произвести любые действия с~данными, которые доступны внутри функции (для языков, имеющих операции арифметики с~указателями, например, C/C++, в~общем случае можно считать, что программа может модифицировать любые данные), и~вернуть произвольное значение. Для~уточнения эффектов может использоваться анализ атрибутов доступной декларации функции, например, информация о~модификаторах типов аргументов функции, атрибуты аргументов и~самой функции. Так, например, функция, объявленная с~GNU-атрибутом \texttt{\_\_attribute\_\_((pure))}, не~имеет прав на~изменение глобальной памяти и~аргументов, а~функция с~атрибутом \texttt{\_\_attribute\_\_((noreturn))} никогда не~вернёт управление в~вызывающую функцию. Могут также использоваться различные эвристики. Вместе с~тем, приближённое моделирование может решить проблему анализа лишь частично. Из-за невозможности оценки влияния вызова на~состояние программы анализатор может сделать некорректные выводы о~текущем состоянии выполнения программы, что может привести как~к~ложным срабатываниям анализатора (ошибка первого рода), так и~к отсутствию срабатывания в~условиях, когда анализатор должен выдавать диагностическое предупреждение (ошибка второго рода).

\todo{написать про виды чувствительностей}

\section{Межпроцедурный анализ для метода символьного выполнения}

Межпроцедурный анализ при использовании метода символьного выполнения обычно выполняется с использованием метода встраивания \cite{???}. Метод встраивания заключается в моделировании операторов вызываемой функции оператор за оператором, в порядке, определяемом потоком управления функции. В начале моделирования вызова устанавливается соответствие имён, внутренних для вызываемой функции, и имён в контексте вызывающей функции: так, значениями формальных параметров вызываемой функции становятся значения её фактических аргументов в вызывающей функции, объектам ключевых слов \texttt{this} или \texttt{self} ставится в соответствие объект, вызов метода которого моделируется, и т.~д.. Затем функция моделируется так же, как и вызывающая, формируя дальнейший путь выполнения. По окончании моделирования вызова значение, возвращаемое оператором \texttt{return}, становится значением, возвращаемым функцией в контексте вызывающей функции, после чего продолжается моделирование вызывающей функции.

Метод встраивания достаточно прост в реализации и, кроме того, является естественным для смешанного анализа, поскольку соответствует непосредственному выполнению анализируемой программы. Его дополнительное преимущество заключается в сохранении всех видов чувствительностей анализа:

\begin{enumerate}
 \item этот метод сохраняет контекстную чувствительность, поскольку на значения переменных при моделировании вызова функции накладываются ограничения, существующие в вызывающей функции;
 \item метод сохраняет чувствительность к пути выполнения, поскольку \todo{???}
 \item метод сохраняет чувствительность к потоку \todo{???}
\end{enumerate}


Однако метод встраивания имеет недостаток, связанный с масштабируемостью: каждый раз при моделировании вызова функции она анализируется заново, в различных контекстах. Это приводит к большим расходам как процессорного времени, затрачиваемого на анализ, так и к расходам памяти, поскольку информацию, получаемую при моделировании вызова на каждом его шаге, и зачастую необходимую для последующего анализа, необходимо сохранять в памяти. В результате сравнения времени анализа с использованием межпроцедурного анализа методом встраивания и без использования межпроцедурного анализа были получены значения времени \todo{time-1} и \todo{time-2} (для тестирования использовался программный комплекс Clang Static Analyzer). Эти данные показывают заметное увеличение времени анализа. При этом время анализа зависело от размера исходного файла следующим образом: \todo{графики}.

Поскольку нашей задачей является сохранение всех видов чувствительности анализа


\todo{!!!}


Таким образом, нашей задачей является построение такого метода межпроцедурного анализа для метода символьного выполнения, который будет обладать следующими свойствами:

\begin{enumerate}
 \item сохранение всех видов чувствительности анализа, т.~е. метод МПА должен сохранять контекстную чевствительность, чувствительность к пути и чувствительность к потоку;
 \item высокая масштабируемость: разрабатываемый метод должен позволять анализ крупных программных систем за приемлемое время;
 \item достаточная точность анализа: реализация разрабатываемого метода не должна уступать методу встраивания в количестве корректных срабатываний (и, по возможности, не допускать пропусков дефектов) и в отношении количества корректных срабатываний к общему количеству срабатываний.
\end{enumerate}


%\newpage
%============================================================================================================================

\section{Ссылки} \label{sect1_2}
Сошлёмся на библиографию. Одна ссылка: \cite[с.~54]{Sokolov}\cite[с.~36]{Gaidaenko}. Две ссылки: \cite{Sokolov,Gaidaenko}. Много ссылок:  \cite[с.~54]{Lermontov,Management,Borozda} \cite{Lermontov,Management,Borozda,Marketing,Constitution,FamilyCode,Gost.7.0.53,Razumovski,Lagkueva,Pokrovski,Sirotko,Lukina,Methodology,Encyclopedia,Nasirova,Berestova,Kriger}. И ещё немного ссылок: \cite{Article,Book,Booklet,Conference,Inbook,Incollection,Manual,Mastersthesis,Misc,Phdthesis,Proceedings,Techreport,Unpublished}. \cite{medvedev2006jelektronnye, CEAT:CEAT581, doi:10.1080/01932691.2010.513279,Gosele1999161,Li2007StressAnalysis, Shoji199895,test:eisner-sample,AB_patent_Pomerantz_1968,iofis_patent1960}

%Попытка реализовать несколько ссылок на конкретные страницы для стандартной реализации:[\citenum{Sokolov}, с.~54; \citenum{Gaidaenko}, с.~36].

%Несколько источников мультицитата \cites[vii--x, 5, 7]{Sokolov}[v--x, 25, 526]{Gaidaenko} поехали дальше


Сошлёмся на приложения: Приложение \ref{AppendixA}, Приложение \ref{AppendixB2}.

Сошлёмся на формулу: формула \eqref{eq:equation1}.

Сошлёмся на изображение: рисунок \ref{img:knuth}.

%\newpage
%============================================================================================================================

\section{Формулы} \label{sect1_3}

Благодаря пакету \textit{icomma}, \LaTeX~одинаково хорошо воспринимает в качестве десятичного разделителя и запятую ($3,1415$), и точку ($3.1415$).

\subsection{Ненумерованные одиночные формулы} \label{subsect1_3_1}

Вот так может выглядеть формула, которую необходимо вставить в строку по тексту: $x \approx \sin x$ при $x \to 0$.

А вот так выглядит ненумерованая отдельностоящая формула c подстрочными и надстрочными индексами:
\[
(x_1+x_2)^2 = x_1^2 + 2 x_1 x_2 + x_2^2
\]

При использовании дробей формулы могут получаться очень высокие:
\[
  \frac{1}{\sqrt(2)+
  \displaystyle\frac{1}{\sqrt{2}+
  \displaystyle\frac{1}{\sqrt{2}+\cdots}}}
\]

В формулах можно использовать греческие буквы:
\[
\alpha\beta\gamma\delta\epsilon\varepsilon\zeta\eta\theta\vartheta\iota\kappa\lambda\\mu\nu\xi\pi\varpi\rho\varrho\sigma\varsigma\tau\upsilon\phi\varphi\chi\psi\omega\Gamma\Delta\Theta\Lambda\Xi\Pi\Sigma\Upsilon\Phi\Psi\Omega
\]

%\newpage
%============================================================================================================================

\subsection{Ненумерованные многострочные формулы} \label{subsect1_3_2}

Вот так можно написать две формулы, не нумеруя их, чтобы знаки равно были строго друг под другом:
\begin{align}
  f_W & =  \min \left( 1, \max \left( 0, \frac{W_{soil} / W_{max}}{W_{crit}} \right)  \right), \nonumber \\
  f_T & =  \min \left( 1, \max \left( 0, \frac{T_s / T_{melt}}{T_{crit}} \right)  \right), \nonumber
\end{align}

Выровнять систему ещё и по переменной $ x $ можно, используя окружение \verb|alignedat| из пакета \verb|amsmath|. Вот так: 
\[
    |x| = \left\{
    \begin{alignedat}{2}
        &&x, \quad &\text{eсли } x\geqslant 0 \\
        &-&x, \quad & \text{eсли } x<0
    \end{alignedat}
    \right.
\]
Здесь первый амперсанд  означает выравнивание по~левому краю, второй "--- по~$ x $, а~третий "--- по~слову <<если>>. Команда \verb|\quad| делает большой горизонтальный пробел. 

Ещё вариант:
\[
    |x|=
    \begin{cases}
    \phantom{-}x, \text{если } x \geqslant 0 \\
    -x, \text{если } x<0
    \end{cases}
\]

Можно использовать разные математические алфавиты:
\begin{align}
\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber \\
\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber \\
\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \nonumber
\end{align}

Посмотрим на систему уравнений на примере аттрактора Лоренца:

\[ 
\left\{
  \begin{array}{rl}
    \dot x = & \sigma (y-x) \\
    \dot y = & x (r - z) - y \\
    \dot z = & xy - bz
  \end{array}
\right.
\]

А для вёрстки матриц удобно использовать многоточия:
\[ 
\left(
  \begin{array}{ccc}
  	a_{11} & \ldots & a_{1n} \\
  	\vdots & \ddots & \vdots \\
  	a_{n1} & \ldots & a_{nn} \\
  \end{array}
\right)
\]


%\newpage
%============================================================================================================================
\subsection{Нумерованные формулы} \label{subsect1_3_3}

А вот так пишется нумерованая формула:
\begin{equation}
  \label{eq:equation1}
  e = \lim_{n \to \infty} \left( 1+\frac{1}{n} \right) ^n
\end{equation}

Нумерованых формул может быть несколько:
\begin{equation}
  \label{eq:equation2}
  \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{k^2} = \frac{\pi^2}{6}
\end{equation}

Впоследствии на формулы (\ref{eq:equation1}) и (\ref{eq:equation2}) можно ссылаться.

Сделать так, чтобы номер формулы стоял напротив средней строки, можно, используя окружение \verb|multlined| (пакет \verb|mathtools|) вместо \verb|multline| внутри окружения \verb|equation|. Вот так:
\begin{equation} % \tag{S} % tag - вписывает свой текст 
    \begin{multlined}
        1+ 2+3+4+5+6+7+\dots + \\ 
        + 50+51+52+53+54+55+56+57 + \dots + \\ 
        + 96+97+98+99+100=5050 
    \end{multlined}
\end{equation}
