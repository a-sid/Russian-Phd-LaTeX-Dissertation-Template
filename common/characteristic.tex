\actuality\
Для~больших и~сложных программно-технических комплексов полное покрытие всех путей выполнения программы становится невозможным, поскольку эта задача соотносится с проблемой останова. Ресурсы, выделенные на~тестирование сложных программных комплексов, всегда ограничены, что приводит к~необходимости рационального  их использования. Проблема поиска подходящего компромисса  между повышением надежности разрабатываемых программных средств и~эффективным использованием ресурсов становится все актуальнее. Для~обеспечения надёжности программных средств  активно ведётся разработка новых эффективных методов и~средств автоматического тестирования, позволяющих за~реальное время предупредить и~выявить как~можно большее количество дефектов в~программе. В~настоящее время всё большее распространение получают инструменты, предназначенные для~поиска дефектов в~программном коде.

Обычно различают статический, динамический и~смешанный анализ. Под статическим анализом понимают анализ программы, не~требующий её непосредственного выполнения. Часть инструментов, таких, как~Clang Static Analyzer \cite{csa}, PVS-Studio \cite{pvs}, Cppcheck \cite{cppcheck}, Lint \cite{lint}, исследует непосредственно код программы или структуры данные, строящиеся на~его основе,~--- абстрактное синтаксическое дерево или граф потока управления. Другая часть инструментов статического анализа использует для~анализа более низкоуровневое представление программы~--- скомпилированный объектный или промежуточный код (Coverity Prevent \cite{coverity}, Svace \cite{svace}, FindBugs \cite{findbugs}). В~отличие от~статического анализа, для~динамического анализа программы требуется её выполнение~--- на~специальных входных данных, в~виртуальной машине (Valgrind \cite{valgrind}), с~использованием инструментации (AddressSanitizer \cite{asan}, ThreadSanitizer \cite{tsan}, UndefinedBehaviorSanitizer), с~использованием дополнительных библиотек или их подменой. Наконец, смешанный анализ представляет собой комбинацию статического и~динамического анализа и~используется в~таких инструментах как~Mayhem \cite{mayhem}, KLEE \cite{klee}, а~также других автоматических генераторов контрпримеров.

Перечисленные виды анализа имеют свои достоинства и~недостатки, в~частности, различные виды анализа наиболее эффективны для~поиска различных видов ошибок.

\begin{itemize}
 \item Динамический анализ наиболее хорошо зарекомендовал себя для~поиска ошибок, связанных с~многопоточностью и~управлением памятью, однако крайне затратен в~случае больших проектов. Значительным недостатком динамического анализа является необходимость явного выполнения программы, что влечёт за~собой необходимость подготовки входных данных (или их автогенерации), и~быстрый рост длительности такого анализа с~увеличением объёма проекта. Это также затрудняет интеграцию инструментов, использующих динамический анализ, в~процесс разработки, что снижает шансы быстрого обнаружения ошибки.
 \item Статический анализ позволяет эффективно производить поиск различных видов дефектов: опечаток, некорректного использования типов, проблем безопасности, неопределённого или недокументированного поведения и~многих других видов. Инструменты для~выполнения статического анализа могут быть легко интегрированы в~процесс разработки. При~этом они могут быть использованы как~индивидуальные вспомогательные инструменты разработки (например, для~подсветки кода, содержащего потенциальную ошибку), так и~в~качестве инструментов, использующихся группой разработчиков (например, для~развёртывания и~интеграции в~систему непрерывной сборки). Сравнительно небольшое время, затрачиваемое на~анализ, вкупе с~интеграцией в~рабочий процесс позволяет быстро находить дефекты в~разрабатываемых программах. Недостатком статических анализаторов является возможность выдачи ими некорректных сообщений об ошибках~--- ложных срабатываний (ошибок первого рода) и~возможность пропуска имеющихся дефектов (ошибки второго рода), вероятность которых стараются снизить при~разработке анализаторов. Вред от~ошибок второго рода очевиден, но и~ошибки первого рода играют не~меньшую роль при~оценке качества анализатора, поскольку их большое количество отвлекает разработчика на~длительное время для~просмотра ложных срабатываний, поэтому при~большом количестве ложных срабатываний инструмент может стать практически непригодным для~использования. Однако при~небольшом количестве ложных срабатываний польза от~применения анализатора в~виде снижения времени, затрачиваемого на~обнаружение ошибки, быстро перевешивает недостаток в~виде времени, затрачиваемого на~просмотр ложных срабатываний.
\end{itemize}

Первоначально распространение у разработчиков получили инструменты, использующие методы на~основе анализа синтаксического дерева программы и~её графа потока управления. Преимуществами данных методов анализа программного кода являются:

\begin{itemize}
 \item высокая скорость работы,
 \item незначительное потребление памяти,
 \item возможность его реализации в~компиляторе для~выполнения дополнительных проверок и~предупреждения программиста о~потенциально некорректном поведении компилируемого кода. Это становится возможным благодаря малому потреблению системных ресурсов, позволяющему лишь незначительно снижать производительность компилятора,
 \item возможность интеграции в~среды разработки для~осуществления анализа <<на лету>>, непосредственно в~процессе набора кода программистом, или в~качестве дополнительного инструмента для~быстрого обнаружения дефекта.
\end{itemize}

Аналогичные методы применяются в~компиляторах для~предупреждения программиста о~потенциально некорректном поведении программы, поскольку и~синтаксическое дерево, и~граф потока управления являются основными структурами данных, с~которыми работает компилятор. Однако проверка, включаемая в~состав компилятора, должна исключать возможность ложных срабатываний, т.~е. являться консервативной. Инструменты же статического анализа могут включать также и~неконсервативные проверки, с~возможностью выдачи ложных срабатываний.

Данные методы могут обнаруживать лишь очень узкие классы дефектов в~программном коде: простые ошибки, затрагивающие лишь несколько операторов, расположенных в~пределах одной функции. Это может быть простейший поиск использования неинициализированных переменных, ошибок при~преобразовании типов, потенциально лишние операции, а~также другие дефекты, для~поиска которых не~требуется анализировать циклы и~условные переходы. При~наличии циклов и~переходов в~анализируемой функции эффективность видов анализа, нечувствительных к~путям выполнения, резко падает, поскольку данные методы позволяют корректно определить достижимость одних операторов из других операторов при~выполнении программы лишь в~тривиальных случаях.

Значительно более ресурсоёмким, но и~более подробным является анализ на~основе обхода путей выполнения программы. Основы этих методов были заложены ещё в~70-х~годах. Метод символьного выполнения был предложен Джеймсом Кингом в~1976 году \cite{king76}. В~основе метода лежит идея разбиения входных данных на~классы эквивалентности в~зависимости от~встречаемых по пути выполнения условий. Метод абстрактной интерпретации, предложенный в~1977~году супругами Кузо \cite{cousot}, предполагает использовать абстрагирование данных и~их анализ на~основе алгебры решёток. Однако данные походы стали получать распространение только в~последнее время. Это связано с~увеличившейся мощностью компьютеров: время анализа растёт пропорционально количеству путей выполнения, что означает экспоненциальный рост времени анализа с~увеличением размера программы. (Вообще говоря, абсолютно полный и~точный анализ программы невозможен в~связи с~проблемой останова, независимо от~применяемого подхода.) В~отличие от~базового анализа графа потока управления, анализ путей выполнения способен учитывать условия выполнения тех или иных ветвей программы,  следствием чего являются преимущества данного вида анализа~--- его более высокая точность и~способность покрыть намного больший класс дефектов. Такие методы, как~абстрактная интерпретация и~символьное выполнение, нашли применения в~известных инструментах для~поиска дефектов, например, Coverity SAVE, Clang Static Analyzer и~многих других.

Одними из наиболее актуальных целевых языков для~статического анализа традиционно являются языки C и~C++. Причин для~этого несколько. Во-первых, это связано с~большим количеством видов потенциальных ошибок, которые может допустить программист, ведущий разработку с~использованием этих языков. Наиболее специфичными среди таких ошибок являются ошибки, связанные с~неправильной работой с~указателями~--- переполнение буфера, обращение к~неинициализированной памяти или к~памяти по некорректному адресу. Во-вторых, стандарты языков трактуют достаточно большое количество ситуаций как~не~имеющих определённого поведения (например, порядок вычисления аргументов функций может быть произвольным), что, с~одной стороны, позволяет компилятору проводить более глубокие оптимизации и~получить наибольшую скорость выполнения результирующего кода, но, с~другой стороны, требует от~программиста повышенного внимания в~процессе написания кода программы для~учёта этих особенностей. В-третьих, эти языки являются одними из самых распространённых и~известных, с~их использованием было разработано и~продолжает создаваться большое количество как~системного, так и~прикладного программного обеспечения. Кроме того, язык C является практически единственным выбором при~разработке низкоуровневых компонентов, например, компонентов операционных систем и~драйверов, что также предъявляет повышенные требования к~качеству программного кода.

 \aim\ данной работы является разработка метода межпроцедурного межмодульного анализа крупных программных комплексов, разработанных с использованием языков C и C++, способного осуществлять анализ проектов масштаба ОС Android и ОС Tizen за приемлемое время и обеспечивающего достаточное покрытие путей выполнения программы.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать метод межпроцедурного анализа программ с высокой масштабируемостью, пригодный для анализа крупных программных проектов, а также расширяемый на различные классы проверок
  \item Разработать метод межмодульного анализа программ, разработанных с использованием языков C и C++
  \item Разработать метод отображения результатов анализа при использовании разработанного метода межпроцедурного анализа
  \item Реализовать разработанные методы с использованием инфраструктуры статического анализатора Clang Static Analyzer
  \item Осуществить проверку разработанных методов на реальных программных проектах
  \item Провести анализ разработанного метода на предмет масштабируемости и качества анализа с учётом результатов, полученных при проверке реальных программных проектов.
\end{enumerate}

\defpositions
\begin{enumerate}
  \item Разработка модификации метода межпроцедурного анализа программ, пригодной для реализации в многоцелевом статическом анализаторе программного кода на языках C и C++ и позволяющей использовать различные виды проверок кода с целью поиска дефектов.
  \item Разработка метода межмодульного анализа программ, реализованных с использованием языков C и C++, для повышения полноты анализа многокомпонентных систем.
  \item Реализация программного обеспечения (многоцелевой анализатор и его утилиты) на основе предложенных методов с целью его промышленного и коммерческого применения для поиска дефектов в исходном коде программных комплексов.
\end{enumerate}

\novelty

Научная новизна диссертации определяется получением следующих результатов, которые выносятся на защиту:
\begin{enumerate}
  \item Разработана модификация метода межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, реализованных с использованием языков C и C++. Важными особенностями разработанного метода является поддержка проверок произвольного вида и их одновременного выполнения, а также поддержка модели памяти, используемой в языках C и C++, в том числе, с учётом арифметики указателей, наследования и выравнивания полей структур.
  \item Разработан алгоритм переименования областей памяти для трансляции имён переменных между различными функциями, использующий цепочки доступа. Данный алгоритм используется для установления соответствия между различными объектами функций.
  \item Разработан алгоритм построения фрагментов графа выполнения, моделирующих вызов функции, с учётом ограничений на входные данные, известных на момент вызова функции.
  \item Разработан метод межмодульного анализа программ, реализованных с использованием языков C и C++ для статического анализатора, использующего в качестве входных данных непосредственно исходный код программы. Использование промежуточного представления в виде синтаксического дерева программы позволяет производить анализ без потери информации о программе.
  \item Разработан алгоритм построения отчёта о дефекте при использовании предложенной модификации метода резюме для метода символьного выполнения. Данный метод позволяет строить информативный межпроцедурный отчёт, включающий показ переходов, выполнимых условий и представляющих интерес событий в процессе выполнения программы.
  \item Проведён сравнительный анализ метода МПА, использующего встраивание кода функции, и метода МПА, использующего резюме её эффектов. Результаты автоматического и ручного тестирования, проведённого для данных методов, показали значительное преимущество предложенного метода. Тестированием подтверждено как увеличение скорости поиска дефектов, так и увеличение покрытия путей программы при сохранении точности анализа.

\end{enumerate}

\influence\ Разработаны методы анализа программ, применимые для проектов масштаба операционных систем и их наборов пользовательских приложений, реализованные в практически используемом анализаторе программного кода. Предложенные в диссертационной работе методы и алгоритмы позволят  проводить анализ крупных программных систем в автоматизированном режиме и использованы для создания универсального анализатора кодов программ на языках C и C++.

\reliability\ полученных результатов обеспечивается экспериментальным подтверждением и последующей ручной проверкой отчётов анализатора при анализе исходного кода ОС Android версии 4.2.1. Ряд обнаруженных дефектов может быть найден с использованием других статических анализаторов, например, Coverity SAVE или Clang Static Analyzer (с режимом встраивания). Для тестирования был использован открытый исходный код, а разработанная экспериментальная система помещена в открытый доступ, что позволяет воспроизвести эксперименты независимо.
\probation\
Основные результаты работы докладывались~на:
\begin{enumerate}
 \item 10-й Международной Ершовской конференции <<Перспективы систем информатики>> (PSI 2015) (Казань, Россия, 2015)
 \item XII Международной научно-практической конференции <<Инновации на основе информационных и коммуникационных технологий>> (INFO-2015) (Сочи, Россия, 2015)
 \item Открытой конференции по компиляторным технологиям (Россия, Москва, 2015).
\end{enumerate}


\contribution\ Все выносимые на защиту результаты получены лично автором. Программные реализации выполнены совместно с Артёмом Дергачёвым, Евгением Павловым и Юлией Трофимович.

\publications\ Основные результаты по теме диссертации изложены в 6 печатных изданиях~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine,info-2015,psi-2015},
4 из которых изданы в журналах, рекомендованных ВАК~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine}, 
2~--- в тезисах докладов~\cite{info-2015,psi-2015}. В работах \cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine} автору принадлежат теоретические модели, обзорные разделы, описание элементов разработанных методов, а также результаты экспериментального тестирования разработанного в рамках работы ПО.
