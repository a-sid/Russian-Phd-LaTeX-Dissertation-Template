(Слайд 1) Сложность разрабатываемого программного обеспечения постоянно увеличивается. Современные программные комплексы масштаба операционных систем и их пользовательских окружений могут насчитывать миллионы строк программного кода, разделённого на сотни компонентов, взаимодействующих между собой. Такие системы являются структурно сложными и большими, что затрудняет как ручной, так и автоматический поиск дефектов в них из-за трудноотслеживаемых связей между компонентами и большой размерности множества состояний. В подобных условиях ручной поиск дефектов возможен, фактически, только по факту обнаружения некорректного поведения, что значительно затрудняет разработку и сопровождение системы.

(Слайд 2) В связи с этим в последнее время получают распространение инструменты автоматического поиска дефектов и, в частности, статические анализаторы, подтвердившие свои возможности по обнаружению реальных дефектов в коде программ. Их использование включено в ряд методологий разработки безопасного программного обеспечения, такие как Microsoft SDL и TSP-Secure. Такое ПО может применяться на различных стадиях жизненного цикла проекта, от непосредственно разработки до поддержки.

(Слайд 3) Проблема точного и полного межпроцедурного анализа, требуемого для практического применения статических анализаторов, рассматривалась в ряде работ, включая работы, касающиеся инструментов KLEE, Mayhem, CEGAR, Java PathFinder, за авторством Годфруа, Кадара и Энглера. Однако для практического применения требуется система с иными характеристиками, нежели исследовательская: с возможностью построения подробного отчёта, интеграции в процесс разработки, и, главное, с возможностью выполнения проверок различного вида. Единственными известными промышленными статическими анализаторами, имеющими возможность межпроцедурного анализа, являются Coverity Prevent и недавно разработанный Svace. Из отечественных разработок в области статического анализа стоит отметить статические анализаторы PVS-Studio и упомянутый Svace. PVS-Studio вообще не имеет возможности выполнять межпроцедурный анализ. Такую возможность имеет Svace, однако его точность пока несколько недостаточна. Стоит отметить, что данная разработка призвана дополнить Svace как комплекс анализаторов. В связи с этим, целью данной работы стала разработка методов межпроцедурного и межмодульного анализа сложных программных систем, реализованных с использованием языков C и C++, для автоматического поиска дефектов различных видов с целью реализации на их основе программного обеспечения для статического анализа кодов программ.

(Слайд 4) Задачей межпроцедурного анализа является моделирование эффектов, оказываемых на состояние программы в результате вызова функции, на основе текущего состояния программы и определения вызываемой функции. В случае метода символьного выполнения это означает построение новых узлов графа выполнения на основе состояния в заданном узле графа.

(Слайд 5). В данной работе для решения проблемы производительности межпроцедурного анализа при использовании метода символьного выполнения был модифицирован метод межпроцедурного анализа с использованием резюме анализируемой функции. Данный метод подразумевает анализ функции вне контекста вызова со сбором её резюме, и применением резюме для моделирования вызова вместо полного анализа вызова функции.

(Слайд 6). Разработанная модификация нацелена на языки C и C++. Это подразумевает поддержку сложной модели памяти этих языков, включающую не только ссылочные отношения, но и поддержку низкоуровневой работы с памятью. Также разработанный метод поддерживает различные виды проверок и их выполнение в рамках одного прогона, что является необходимым требованием к промышленному анализатору.

(Слайд 7). В число эффектов, выбранных для моделирования, входят модификация нелокальной памяти, инвалидация областей памяти, т.е. пометка их как имеющих неизвестное значение, возврат функцией значения, наложение ограничений на входные данные и изменение состояния конечных автоматов проверок. Данный набор позволил обеспечить полный анализ без значительных потерь информации о состоянии программы, что обеспечивает сохранение точности и полноты анализа.

(Слайд 8) После сбора резюме для моделирования вызова функции резюме применяется. Само резюме представляет собой набор ветвей резюме, каждая из которых соответствует одной конечной точке выполнения функции. Ветви резюме имеет непересекающиеся множества предусловий, при которых соответствующая ветвь резюме достижима. Для применения резюме производится актуализация символьных значений, которые используются в его ветвях, т.е. сопоставление символьных значений в терминах вызывающей и вызываемой функции. Затем определяются множества конкретных значений символьных значений, соответствующих символьным значениям, на основании чего производится отсечение недостижимых ветвей выполнения. Для достижимых ветвей выполнения производится моделирование внешних эффектов функции в виде изменения значений памяти, с результатом возврата функции связывается символьное значение из резюме, после чего резюме применяют проверяющие модули.

(Слайд 9). При выполнении ветви выполнения на символьные значения в ней накладываются ограничения. Результирующее множество конкретных значений для заданного символьного значения определяется пересечением множества конкретных значений этого символьного значения на момент вызова и аналогичного множества в предусловии. Ветвь выполнения является достижимой, если все символьные значения имеют непустое множество конкретных значений.

(Слайд 10). Для установления соответствия между символьными значениями в контексте имён вызывающей и вызываемой функции, для символьного значения необходимо выполнить процедуру актуализации. Символьное значение представляет собой дерево, ссылающееся на атомарные символы и константы. Если атомарный символ принадлежит региону памяти, ссылка на этот регион в контексте вызываемой функции заменяется на соответствующую область памяти в контексте вызывающей функции с последующим вычислением полученного дерева.

(Слайд 11). Сопоставление регионов памяти осуществляется с помощью построения и применения цепочек доступа. Затем символьные значения уточнённых регионов памяти используются для построения новых символьных или конкретных значений в контексте вызывающей функции.


(Слайд 12). Для анализа дефекта требуется подробный отчёт, в котором будет показан путь выполнения, приводящий к дефекту. Поскольку при использовании метода резюме происходит потеря информации о пути, проходимом внутри вызываемой функции, в данной работе предлагается хранить в узле применения резюме ссылку на соответствующий конечный узел графа выполнения вызываемой функции, что позволяет строить отчёт с помощью обхода графов выполнения от конечных узлов к корню. При хранении всего стека применения резюме можно строить отчёты произвольной вложенности аналогичным способом.

(Слайд 13). Межмодульный анализ требуется для интеграционного тестирования системы. Кроме того, языки C и C++ поощряют использование раздельной компиляции, что делает межмодульный анализ необходимым для обеспечения его полноты даже для внутрикомпонентного анализа. В данной работе предложен трёхфазный анализ с использования слияния синтаксических деревьев единиц трансляции. На первой стадии происходит перехват команд вызова компилятора и построение на из основе сериализованных синтаксических деревьев, а также списков импортируемых/экспортируемых функций и локальных графов вызовов. С использованием данных списков строится глобальный граф вызовов, анализируемый в топологическом порядке. В качестве анализатора для реализации предлагаемых в данной работе методов анализа использован открытый статический анализатор Clang Static Analyzer.

(Слайд 14). На данном слайде представлена диаграмма компонентов разработанной системы. Белым цветом обозначены компоненты, полностью разработанные в рамках данной работы, а серым - модифицированные.

(Слайд 15). В работе реализован межмодульный анализ с использованием слияния синтаксических деревьев единиц трансляции. Этот подход предполагает полное сохранение информации о программе, что обеспечивает возможность осуществления комбинированных проверок, а также избежать потерь в точности анализа. Также реализованный метод не требует дополнительной поддержки со стороны межпроцедурного анализа.

(Слайд 16). Для тестирования был использован исходный код пользовательского окружения ОС Android версии 4.2.1. Тестирование проходило на сервере с 32 виртуальными процессорными ядрами и 96 Гб памяти. При тестировании производилось сравнение метода МПА с помощью встраивания функции и разработанного метода МПА, использующего резюме.

(Слайд 17). На графиках представлены зависимости характеристик анализа - количества обработанных узлов графа выполнения и количества срабатываний - в различных режимах работы анализатора. По результатам тестирования можно увидеть, что количество обрабатываемых в единицу времени узлов увеличилось на порядок, в 10-11 раз, ...

(Слайд 18). ... а количество срабатываний в единицу времени (графики представлены на этом слайде) - в 3-4 раза. Точность при использовании метода составила от 81 до 84%, т.е. не изменилась.

(Слайд 19) Таким образом, поставленные задачи настоящего исследования достигнуты. 
