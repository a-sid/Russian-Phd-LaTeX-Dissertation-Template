(Слайд 1) Для разработки надёжного программного обеспечения требуется обеспечивать исходный код максимально возможным покрытием тестами. Однако для больших программных систем ручное тестирование покрывает лишь малую часть возможных путей выполнения программы. В связи с этим в последнее время получают распространение инструменты автоматического поиска дефектов и, в частности, статические анализаторы, подтвердившие свои возможности по обнаружению реальных дефектов в коде программ. Однако для получения приемлемого покрытия требуется межпроцедурный анализ, которого коммерческие статические анализаторы избегают из-за увеличения времени рабты инструмента и увеличения доли ложных срабатываний.

(Слайд 2) Проблема точного и полного межпроцедурного анализа, требуемого для практического применения статических анализаторов, рассматривалась в ряде работ, включая работы, касающиеся инструментов KLEE, Mayhem, CEGAR, Java PathFinder, за авторством Годфруа, Кадара и Энглера. Однако для практического применения требуется система с иными характеристиками, нежели исследовательская: с возможностью построения подробного отчёта, интеграции в процесс разработки, и, главное, с возможностью выполнения проверок различного вида. Единственными известными промышленными статическими анализаторами, имеющими возможность межпроцедурного анализа, являются Coverity Prevent и недавно разработанный Svace. Из отечественных разработок в области статического анализа стоит отметить статические анализаторы PVS-Studio и упомянутый Svace. PVS-Studio вообще не имеет возможности выполнять межпроцедурный анализ. Такую возможность имеет Svace, однако его точность пока несколько недостаточна. Стоит отметить, что данная разработка призвана дополнить Svace как комплекс анализаторов. В связи с этим, целью данной работы стала разработка методов межпроцедурного и межмодульного анализа сложных программных систем, реализованных с использованием языков C и C++, для автоматического поиска дефектов различных видов с целью реализации на их основе программного обеспечения для статического анализа кодов программ.

(Слайд 3) Задачей межпроцедурного анализа является моделирование эффектов, оказываемых на состояние программы в результате вызова функции, на основе текущего состояния программы и определения вызываемой функции. В случае метода символьного выполнения, который используется в данной работе, это означает построение новых узлов графа выполнения на основе состояния в заданном узле графа.

(Слайд 4). В данной работе для решения проблемы производительности межпроцедурного анализа при использовании метода символьного выполнения был модифицирован метод межпроцедурного анализа с использованием резюме анализируемой функции. Данный метод подразумевает анализ функции вне контекста вызова со сбором её резюме, и применением резюме для моделирования вызова вместо полного анализа вызова функции.

(Слайд 5). Разработанная модификация нацелена на языки C и C++. Это подразумевает поддержку сложной модели памяти этих языков, включающую не только ссылочные отношения, но и поддержку низкоуровневой работы с памятью. Также разработанный метод поддерживает различные виды проверок и их выполнение в рамках одного прогона, что является необходимым требованием к промышленному анализатору.

(Слайд 7). В число эффектов, выбранных для моделирования, входят модификация нелокальной памяти, инвалидация областей памяти, т.е. пометка их как имеющих неизвестное значение, возврат функцией значения, наложение ограничений на входные данные и изменение состояния конечных автоматов проверок. Данный набор позволил обеспечить полный анализ без значительных потерь информации о состоянии программы, что обеспечивает сохранение точности и полноты анализа.

(Слайд 8) После сбора резюме для моделирования вызова функции резюме применяется. Само резюме представляет собой набор ветвей резюме, каждая из которых соответствует одной конечной точке выполнения функции. Для применения резюме предусловия, при которых достижима соответствующая ветвь, применяются к состоянию программы на момент вызова функции. В результате получается набор достижимых ветвей выполнения с уточнёнными предусловиями достижимости. Для этих ветвей выполнения производится моделирование внешних эффектов функции в виде изменения значений памяти, с результатом возврата функции связывается символьное значение из резюме. После чего своё резюме применяют проверяющие модули.

(Слайд 9). При выполнении ветви выполнения на символьные значения в ней накладываются ограничения. Результирующее множество конкретных значений для заданного символьного значения определяется пересечением множества конкретных значений этого символьного значения на момент вызова и аналогичного множества в предусловии. Ветвь выполнения является достижимой, если все символьные значения имеют непустое множество конкретных значений.

(Слайд 10). Для установления соответствия между символьными значениями в контексте имён вызывающей и вызываемой функции, для символьного значения необходимо выполнить процедуру актуализации. Символьное значение представляет собой дерево, ссылающееся на атомарные символы и константы. Если атомарный символ принадлежит региону памяти, ссылка на этот регион в контексте вызываемой функции заменяется на соответствующую область памяти в контексте вызывающей функции с последующим вычислением полученного дерева.

(Слайд 11). Символьные значения или хранятся в регионах памяти, или ссылаются на них, поэтому в вызывающей и вызываемой функции их нужно сопоставлять. Эта процедура осуществляется с помощью построения и применения цепочек доступа. Затем символьные значения уточнённых регионов памяти используются для построения новых символьных или конкретных значений в контексте вызывающей функции.

(Слайд 12). Для анализа дефекта требуется подробный отчёт, в котором будет показан путь выполнения, приводящий к дефекту. Поскольку при использовании метода резюме происходит потеря информации о пути, проходимом внутри вызываемой функции, в данной работе предлагается хранить в узле применения резюме ссылку на соответствующий конечный узел графа выполнения вызываемой функции, что позволяет строить отчёт с помощью обхода графов выполнения от конечных узлов к корню. При хранении всего стека применения резюме можно строить отчёты произвольной вложенности аналогичным способом.

(Слайд 13). Межмодульный анализ требуется для интеграционного тестирования системы. Кроме того, языки C и C++ поощряют использование раздельной компиляции, что делает межмодульный анализ необходимым для обеспечения его полноты даже для внутрикомпонентного анализа. В данной работе предложен трёхфазный анализ с использования слияния синтаксических деревьев единиц трансляции. На первой стадии происходит перехват команд вызова компилятора и построение на их основе сериализованных синтаксических деревьев, а также списков импортируемых/экспортируемых функций и локальных графов вызовов. С использованием данных списков строится глобальный граф вызовов, анализируемый в топологическом порядке. В качестве анализатора для реализации предлагаемых в данной работе методов анализа использован открытый статический анализатор Clang Static Analyzer.

(Слайд 14). На данном слайде представлена диаграмма компонентов разработанной системы. Белым цветом обозначены компоненты, полностью разработанные в рамках данной работы, а серым - модифицированные.

(Слайд 15). В работе реализован межмодульный анализ с использованием слияния синтаксических деревьев единиц трансляции. Этот подход предполагает полное сохранение информации о программе, что обеспечивает возможность осуществления комбинированных проверок, а также избежать потерь в точности анализа. Также реализованный метод не требует дополнительной поддержки со стороны межпроцедурного анализа.

(Слайд 16). Для тестирования был использован исходный код пользовательского окружения ОС Android версии 4.2.1. Тестирование проходило на сервере с 32 виртуальными процессорными ядрами и 96 Гб памяти. При тестировании производилось сравнение метода МПА с помощью встраивания функции и разработанного метода МПА, использующего резюме.

(Слайд 17). На графиках представлены зависимости характеристик анализа - количества обработанных узлов графа выполнения и количества срабатываний - в различных режимах работы анализатора. По результатам тестирования можно увидеть, что количество обрабатываемых в единицу времени узлов, увеличилось на порядок, в 10-11 раз, что означает существенный рост  выросло количество покрываемых тестами.

(Слайд 18). Соответственно, выросло в 3-4 раза количество срабатываний в единицу времени, что особенно актуально при межмодульном анализе. Точность при использовании метода составила от 81 до 84%, т.е. не изменилась.

(Слайд 19) Таким образом, поставленные задачи настоящего исследования достигнуты. Были разработаны пригодная для практической реализации модификация метода МПА с использованием резюме и метод межмодульного анализа с использованием слияния синтаксических деревьев. Разработано программное обеспечение, использующее эти методы, на основе открытого статического анализатора Clang Static Analyzer, что позволило производить значительно более полный анализ программных проектов без существенного увеличения времени. Разработанное ПО доступно в открытом доступе.
