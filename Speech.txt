(Слайд 1) Сложность разрабатываемого программного обеспечения постоянно увеличивается. Современные программные комплексы масштаба операционных систем и их пользовательских окружений могут насчитывать миллионы строк программного кода, разделённого на сотни компонентов, взаимодействующих между собой. Такие системы являются структурно сложными и большими, что затрудняет как ручной, так и автоматический поиск дефектов в них из-за трудноотслеживаемых связей между компонентами и большой размерности множества состояний.

(Слайд 2) В качестве примера можно взять пользовательское окружение операционной системы Android 4.2.1. Оно насчитывает более 300 взаимосвязанных высокоуровневых компонентов, использующих 10 млн. строк кода только на языках C и C++.

(Слайд 3) В подобных условиях ручной поиск дефектов возможен, фактически, только по факту обнаружения некорректного поведения, что значительно затрудняет разработку и сопровождение системы.

(Слайд 4) В связи с этим в последнее время получают распространение инструменты автоматического поиска дефектов и, в частности, статические анализаторы, подтвердившие свои возможности по обнаружению реальных дефектов в коде программ. Их использование включено в ряд методологий разработки безопасного программного обеспечения, такие как Microsoft SDL и TSP-Secure. Такое ПО может применяться на различных стадиях жизненного цикла проекта, от непосредственно разработки до поддержки.

(Слайд 5). Вместе с тем, проблема полного и точного статического анализа программы является алгоритмически неразрешимой, поскольку для произвольной программы невозможно доказать наличие или отсутствие у неё произвольного свойства. В связи с эти возникает необходимость поиска компромисса между таким характеристиками анализа программы, как точность, полнота и скорость. Для критичных к качеству систем требуется высокая полнота анализа с целью обнаружения наибольшего количества дефектов. Такой анализ должен быть мепроцедурным и межмодульным. Вместе с тем, для сложных систем исследование отчёта о дефекте является длительным процессом, что требует снижения количества ложных срабатываний. Высокое количество ложных срабатываний требуется также для повышения комфорта работы с инструментом. Однако методы, имеющие подобные характеристики, имеют экспоненциальную сложность.
(Слайд 6). Таким образом, задача исследования, разработки и улучшения методов статического анализа является актуальной.

(Слайд 7). Метод символьного выполнения, описанный в 76-ом году Кингом, обладает такими характеристиками. Его идея заключается в разбиении множества возможных входных  данных на классы эквивалентности в зависимости от условий, встречаемых на пути выполнения программы. Этот метод нашёл применение в таких инструментах анализа кода как KLEE и Mayhem, и начинает получать распространение в связи с растущими вычислительными мощностями. Однако метод имеет известные недостатки, в число которых взодит проблема экспоненциального роста количества анализируемых путей. Одним из факторов роста является использование межпроцедурного анализа, поскольку он резко увеличивает длину пути выполнения и количество путей. Традиционно используемый для межпроцедурного анализа метод встраивания предполагает многократный анализ функций, что негативно сказывается на производительности анализа.

(Слайд 8). Целью работы является разработка методов межпроцедурного и межмодульного анализа больших и сложных программных систем, реализованных на языках C и C++, для построения универсального анализатора для среды автоматического тестирования с целью повышения эффективности анализа кодов программ.

(Слайд 9). Идея метода резюме заключается в анализе функции вне контекста вызова с целью сбора информации, необходимой для моделирования эффекта вызова функции на состояние программы. В результате встраивание и повторный анализ функции заменяется применением её резюме к модели состояния программы на момент вызова.

(Слайд 10). Анализируя вычислительные затраты на межпроцедурный анализ методом резюме и методом встраивания, можно заключить, что анализ с использованием резюме будет быстрее анализа методом встраивания, если среднее время применения резюме будет меньше, чем время анализа встраиванием. Для выполнения этого условия необходимо выбрать набор эффектов, моделирование которых достаточно для корректного изменения состояния программы.

(Слайд 11). В число эффектов, выбранных для моделирования, входят модификация нелокальной памяти, инвалидация областей памяти, возврат функцией значения, наложение ограничений на входные данные и изменение состояния конечных автоматов проверок. Данный набор позволил обеспечить полный анализ без значительных потерь информации о состоянии программы.

(Слайд 12). При выполнении ветви выполнения на символьные значения в ней накладываются ограничения. Результирующее множество конкретных значений для заданного символьного значения определяется пересечением множества конкретных значений этого символьного значения на момент вызова и аналогичного множества в предусловии. Ветвь выполнения является достижимой, если все символьные значения имеют непустое множество конкретных значений.

(Слайд 13). В работе доказано, что при использовании различных стратегий проверок в случае идеального анализатора множество найденных дефектов при использовании метода резюме, включает в себя множество дефектов, находимых при использовании метода встраивания. Это означает отсутствие потерь в полноте анализа программы разрабатываемым методов.

(Слайд 14). К промышленно используемому анализатору предъявляется требование универсальности, т.е. возможности поиска различных видов дефектов. Каждый проверяющий модуль строит собственное резюме. Для упрощения поддержки анализом проверяющими модулями можно реализовать набор типовых операций, а именно отложенные проверки, хранение информации о внутренних структурах анализатора и информацию об изменении состояния конечного автомата проверки.

(Слайд 15). Для установления соответствия между символьными значениями в контексте имён вызывающей и вызываемой функции, для символьного значения необходимо выполнить процедуру актуализации. Для этого с помощью построения и применения цепочек доступа производится актуализация всех регионов памяти, на которые ссылаются символьные значения. Затем символьные значения уточнённых регионов памяти используются для построения новыхсимвольных или конкретных значений в контексте вызывающей функции.

(Слайд 16). Для анализа дефекта требуется подробный отчёт, в котором будет показан путь выполнения, приводящий к дефекту. Поскольку при использовании метода резюме происходит потеря информации о пути, проходимом внутри вызываемой функции, в данной работе предлагается хранить в узле применения резюме ссылку на соответствующий конечный узел графа выполнения вызываемой функции, что позволяет строить отчёт с помощью обхода графов выполнения от конечных узлов к корню.

(Слайд 17). При хранении всего стека применения резюме можно строить отчёты
произвольной вложенности аналогичным способом.

(Слайд 18). Межмодульный анализ требуется для интеграционного тестирования системы. Кроме того, языки C и C++ поощряют использование раздельной компиляции, что делает межмодульный анализ необходимым для обеспечения его полноты даже для внутрикомпонентного анализа. В данной работе предложен трёхфазный анализ с использования слияния синтаксических деревьев единиц трансляции. На первой стадии происходит перехват команд вызова компилятора и построение на из основе сериализованных синтаксических деревьев, а также списков импортируемых/экспортируемых функций и локальных графов вызовов. С использованием данных списков строится глобальный граф вызовов, анализируемый в топологическом порядке. В качестве анализатора для реализации предлагаемых в данной работе методов анализа использован открытый статический анализатор Clang Static Analyzer.
(Слайд 19). В работе реализован межмодульный анализс использованием слияния синтаксических деревьев единиц трансляции...
