\actuality\
Инструменты, предназначенные для~поиска дефектов в~программном коде, в~настоящее время получают всё большее распространение. Практика использования инструментов статического и динамического анализа закреплена в ряде методологий разработки безопасного программного обеспечения, таких как Microsoft SDL и TSP-Secure. Активное внедрение инструментов статического анализа объясняется практическим подтверждением их возможностей по обнаружению реальных дефектов в коде программ. 

Различные инструменты сильно различаются по характеристикам анализа: возможностям обнаружения дефектов (полноте), точности и скорости поиска. В основе этого разрыва лежит математическое обоснование. Задача точного и полного анализа программ на предмет поиска дефектов является алгоритмически неразрешимой, поскольку, согласно теореме Райса, невозможно для произвольной программы доказать её соответствие заданному нетривиальному свойству. Это приводит к необходимости применения различных ограничений и эвристик, что заставляет искать компромисс между достигаемыми характеристиками. Различные методы статического анализа имеют различное соотношение между этими характеристиками. %Так, анализ на основе поиска соответствий абстрактного синтаксического дерева, работает за линейное или близкое к линейному время и может иметь хорошую точность, но обладает низкой полнотой анализа. Анализ на основе поиска в графе потока управления имеет хорошую полноту и работает за полиномиальное время, но имеет не слишком высокую точность.

К анализу программных систем с высокими требованиями к качеству предъявляется требование высокой полноты анализа для обнаружения максимально возможного количества дефектов. Подобные анализаторы должны поддерживать межпроцедурный и межмодульный анализ программ. С увеличением сложности системы возрастает время оценки корректности отчёта о дефекте и, соответственно, стоимость просмотра ложных срабатываний. Это значит, что при анализе сложных программных систем также требуется высокая точность. Однако алгоритмы анализа с подобными характеристиками имеют экспоненциальную сложность, из-за чего они начали получать распространение лишь в последнее время. Анализ длинных путей выполнения, имеющихся в \todo{сложных программных системах}, с использованием данных алгоритмов требует длительного времени. Однако статический анализ имеет смысл применять постоянно в процессе разработки. Желательно также иметь возможность проводить анализ <<на лету>>, что также предъявляет повышенные требования к скорости анализа.

Таким образом, повышение производительности межпроцедурного статического анализа имеет важную практическую значимость. Увеличение производительности позволяет производить более полный и точный анализ крупных программ и программных систем, уменьшая время на поиск дефектов, а также позволяет ускорять анализ небольших программ.

Вопросы точного и полного, в т.~ч., межпроцедурного анализа рассматривались различными исследователями. Основополагающей в этой области может считаться работа J.~King (1976~г.), описывающая метод символьного выполнения программы. В~основе метода лежит идея разбиения входных данных на~классы эквивалентности в~зависимости от~встречаемых по пути выполнения условий. Метод встраивания для  \todo{Pnueli, 1981}. Подход к МПА на основе резюме был применён для смешанного анализа в работах Patrice Godefroid и впоследствии использован для реализации отдельных видов проверок в исследовательских работах Saswat Anand, Koushik Sen и George Necula, Jos\'{e} Miguel Rojas и Corina S. P\u{a}s\u{a}reanu. Попытка использовать резюме для моделирования циклов предпринималась в работах A.~Tsitovich и N.~Sharygina.

Однако данные работы посвящены исследованию одного конкретного дефекта. Кроме того, в работах использован не статический, а смешанный и динамический анализ. В настоящее время требуется подход, который бы обеспечил возможность выполнения проверок произвольного вида, поскольку разработка одноцелевого анализатора является нецелесообразной.

Для~больших и~сложных программно-технических комплексов полное покрытие всех путей выполнения программы становится невозможным, поскольку эта задача соотносится с проблемой останова. Ресурсы, выделенные на~тестирование сложных программных комплексов, всегда ограничены, что приводит к~необходимости рационального  их использования. Проблема поиска подходящего компромисса  между повышением надежности разрабатываемых программных средств и~эффективным использованием ресурсов становится все актуальнее. Для~обеспечения надёжности программных средств  активно ведётся разработка новых эффективных методов и~средств автоматического тестирования, позволяющих за~реальное время предупредить и~выявить как~можно большее количество дефектов в~программе. В~настоящее время всё большее распространение получают инструменты, предназначенные для~поиска дефектов в~программном коде.

Обычно различают статический, динамический и~смешанный анализ. Под статическим анализом понимают анализ программы, не~требующий её непосредственного выполнения. Часть инструментов, таких, как~Clang Static Analyzer, PVS-Studio, Cppcheck, Lint, исследует непосредственно код программы или структуры данные, строящиеся на~его основе,~--- абстрактное синтаксическое дерево или граф потока управления. Другая часть инструментов статического анализа использует для~анализа более низкоуровневое представление программы~--- скомпилированный объектный или промежуточный код (Svace, FindBugs). В~отличие от~статического анализа, для~динамического анализа программы требуется её выполнение~--- на~специальных входных данных, в~виртуальной машине (Valgrind), с~использованием инструментации (AddressSanitizer, ThreadSanitizer), с~использованием дополнительных библиотек или их подменой. Наконец, смешанный анализ представляет собой комбинацию статического и~динамического анализа и~используется в~таких инструментах как~Mayhem, KLEE, а~также других автоматических генераторах контрпримеров.

Перечисленные виды анализа имеют свои достоинства и~недостатки, в~частности, различные виды анализа наиболее эффективны для~поиска различных видов ошибок. Статический анализ позволяет эффективно производить поиск различных видов дефектов: опечаток, некорректного использования типов, проблем безопасности, неопределённого или недокументированного поведения и~многих других видов. Инструменты для~выполнения статического анализа могут быть легко интегрированы в~процесс разработки. При~этом они могут быть использованы как~индивидуальные вспомогательные инструменты разработки (например, для~подсветки кода, содержащего потенциальную ошибку), так и~в~качестве инструментов, использующихся группой разработчиков (например, для~развёртывания и~интеграции в~систему непрерывной сборки). Сравнительно небольшое время, затрачиваемое на~анализ, вкупе с~интеграцией в~рабочий процесс позволяет быстро находить дефекты в~разрабатываемых программах.

Первоначально распространение у разработчиков получили инструменты, использующие методы на~основе анализа синтаксического дерева программы и~её графа потока управления. Преимуществами данных методов анализа программного кода являются:

\begin{itemize}
 \item высокая скорость работы и незначительное потребление памяти
 \item возможность его реализации в~компиляторе для~выполнения дополнительных проверок и~предупреждения программиста о~потенциально некорректном поведении компилируемого кода
 \item возможность интеграции в~среды разработки для~осуществления анализа <<на лету>>, непосредственно в~процессе набора кода программистом, или в~качестве дополнительного инструмента для~быстрого обнаружения дефекта.
\end{itemize}

Аналогичные методы применяются в~компиляторах для~предупреждения программиста о~потенциально некорректном поведении программы, поскольку и~синтаксическое дерево, и~граф потока управления являются основными структурами данных, с~которыми работает компилятор. Однако проверка, включаемая в~состав компилятора, должна исключать возможность ложных срабатываний, т.~е. являться консервативной. Инструменты же статического анализа могут включать также и~неконсервативные проверки, с~возможностью выдачи ложных срабатываний.

Данные методы могут обнаруживать лишь очень узкие классы дефектов в~программном коде: простые ошибки, затрагивающие лишь несколько операторов, расположенных в~пределах одной функции. Это может быть простейший поиск использования неинициализированных переменных, ошибок при~преобразовании типов, потенциально лишние операции, а~также другие дефекты, для~поиска которых не~требуется анализировать циклы и~условные переходы. Значительно более ресурсоёмким, но и~более подробным является анализ на~основе обхода путей выполнения программы. Основы этих методов были заложены ещё в~70-х~годах. Метод символьного выполнения был предложен Джеймсом Кингом в~1976 году. В~основе метода лежит идея разбиения входных данных на~классы эквивалентности в~зависимости от~встречаемых по пути выполнения условий. Метод абстрактной интерпретации, предложенный в~1977~году супругами Кузо, предполагает использовать абстрагирование данных и~их анализ на~основе алгебры решёток. Однако данные походы стали получать распространение только в~последнее время. Это связано с~увеличившейся мощностью компьютеров: время анализа растёт пропорционально количеству путей выполнения, что означает экспоненциальный рост времени анализа с~увеличением размера программы. В~отличие от~базового анализа графа потока управления, анализ путей выполнения способен учитывать условия выполнения тех или иных ветвей программы,  следствием чего являются преимущества данного вида анализа~--- его более высокая точность и~способность покрыть намного больший класс дефектов. Такие методы, как~абстрактная интерпретация и~символьное выполнение, нашли применения в~известных инструментах для~поиска дефектов, например, Coverity SAVE и Clang Static Analyzer.

Одним из способов увеличения производительности и покрытия при использовании метода символьного выполнения является использование \textit{резюме} при межпроцедурном анализе. Этот подход позволяет повторное использование данных анализа функции для моделирования её вызовов. Исследованию этого метода посвящён ряд наиболее близких теме настоящей диссертации работ, в частности. %\footcite{godefroid-comp,anand-godefroid,may-must}.

Одними из наиболее актуальных целевых языков для~статического анализа традиционно являются языки C и~C++. Во-первых, это связано с~большим количеством видов потенциальных ошибок, которые может допустить программист, ведущий разработку с~использованием этих языков. Наиболее специфичными среди таких ошибок являются ошибки, связанные с~неправильной работой с~указателями. Во-вторых, стандарты языков трактуют достаточно большое количество ситуаций как~не~имеющих определённого или зависимого от реализации поведения. Это позволяет компилятору проводить более глубокие оптимизации и~получить наибольшую скорость выполнения результирующего кода. Однако от~программиста требуется повышенное внимание в~процессе написания кода программы для~учёта этих особенностей. В-третьих, эти языки являются одними из самых распространённых и~известных, с~их использованием было разработано и~продолжает создаваться большое количество как~системного, так и~прикладного программного обеспечения. Кроме того, язык C является практически единственным выбором при~разработке низкоуровневых компонентов, таких как компоненты операционных систем и~драйверы, что также предъявляет повышенные требования к~качеству программного кода.

\todo{Как следует из теоремы Райса, проблема анализа программ, в общем случае алгоритмически неразрешима: невозможно для произвольной программы доказать её соответствие заданному нетривиальному свойству. Алгоритмическая неразрешимость проблемы статического анализа приводит к необходимости применения различных ограничений и эвристик. Это, в свою очередь, заставляет искать компромисс между полнотой анализа, его качеством и производительностью. Повышение производительности статического анализа имеет важную практическую значимость. Увеличение производительности позволяет производить более полный и точный анализ крупных программ и программных комплексов, уменьшая время на поиск дефектов, а также позволяет ускорять анализ небольших программ. Таким образом, задача повышения производительности статического анализа исходного кода программ является по-прежнему актуальной.}

\aim\ данной работы является построение метода анализа крупных программных комплексов, разработанных с использованием языков C и C++, способного осуществлять анализ проектов масштаба ОС Android и ОС Tizen \todo{(порядка 5--20~млн. строк кода)} за приемлемое время и обеспечивающего достаточное покрытие путей выполнения программы.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать метод межпроцедурного анализа программ, пригодный для анализа крупных программных проектов, а также расширяемый на различные классы проверок
  \item Разработать метод межмодульного анализа программ, разработанных с использованием языков C и C++
  \item Разработать метод отображения результатов анализа при использовании предложенного метода межпроцедурного анализа
  \item Для экспериментального подтверждения эффективности предложенных методов реализовать их для использования в приложении-анализаторе (Clang Static Analyzer, анализатор с открытым исходным кодом) и осуществить тестирование разработанных методов на реальных программных проектах~--- пакетах пользовательского окружения ОС Android
  \item По результатам тестирования сделать выводы о пригодности разработанного метода, о его масштабируемости и качестве анализа кода программ
\end{enumerate}

\defpositions
\begin{enumerate}
  \item Новая модификация метода межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, разработанных с использованием языков C и C++
  \item Метод межмодульного анализа программ, разработанных с использованием языков C и C++, архитектура анализатора, эвристики, связанные с объединением синтаксических деревьев различных единиц трансляции
  \item Метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
\end{enumerate}

\novelty

В работе получены следующие основные результаты, обладающие научной новизной:
\begin{enumerate}
  \item Разработана новая модификация метода межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, реализованных с использованием языков C и C++. Данный метод анализа позволяет производить анализ с высоким качеством и полнотой, однако имеет экспоненциальную сложность, связанную с проблемой роста количества путей с увеличением объёма программы (path explosion), что делает задачу улучшения его производительности особенно актуальной. Важными особенностями разработанного метода является поддержка проверок произвольного вида и их одновременного выполнения, а также поддержка модели памяти, используемой в языках C и C++, в том числе, с учётом арифметики указателей, наследования и выравнивания полей структур.
  \item Разработан метод межмодульного анализа программ, реализованных с использованием языков C и C++ для статического анализатора, использующего в качестве входных данных непосредственно исходный код программы. Использование промежуточного представления в виде синтаксического дерева программы позволяет производить анализ без потери информации о программе.
  \item Разработан метод построения отчёта о дефекте при использовании предложенной модификации метода резюме для метода символьного выполнения. Данный метод позволяет строить информативный межпроцедурный отчёт, включающий показ переходов, выполнимых условий и представляющих интерес событий в процессе выполнения программы.
\end{enumerate}

\influence\ Разработаны методы анализа программ, применимые для проектов масштаба операционных систем и их наборов пользовательских приложений. Программное обеспечение, реализующее разработанные методы, внедрено в Samsung Electronics и используется для анализа исходного кода ПО различного назначения, в частности, мобильных приложений и операционных систем, телевизионное ПО, ПО медицинских систем, и может использоваться для других программных систем, включая настольные приложения и крупные системы управления. \todo{Результаты тестирования, сравнивающего предложенную модификацию метода резюме и метод встраивания, показали значительное преимущество предложенного метода. Тестированием подтверждено увеличение скорости поиска дефектов: одинаковое количество дефектов можно обнаружить за время, в 2--3 раза меньшее. Продемонстрировано увеличение покрытия путей программы: при одинаковом времени анализа предложенным методом обрабатывается в 9--10 раз больше операторов программы, чем при использовании метода встраивания. При этом качество анализа сохраняется: доля корректных срабатываний варьировалась от 80\% до 84\% в зависимости от настроек анализатора.}

\reliability\ полученных результатов обеспечивается экспериментальным подтверждением и последующей ручной проверкой отчётов анализатора при анализе исходного кода ОС Android версии 4.2.1. Ряд обнаруженных дефектов может быть найден с использованием других статических анализаторов, например, Coverity SAVE или Clang Static Analyzer (с режимом встраивания). Для тестирования был использован открытый исходный код, а разработанная экспериментальная система помещена в открытый доступ, что позволяет воспроизвести эксперименты независимо. Теоретический вывод о совпадении множества дефектов при некоторых способах проверки, сделанный в данной работе, озвучивается также в.

\probation\
Основные результаты работы докладывались~на:
\begin{enumerate}
 \item 10-й Международной Ершовской конференции <<Перспективы систем информатики>> (PSI 2015) (Казань, Россия, 2015)
 \item XII Международной научно-практической конференции <<Инновации на основе информационных и коммуникационных технологий>> (INFO-2015) (Сочи, Россия, 2015)
 \item Открытой конференции по компиляторным технологиям (Россия, Москва, 2015).
\end{enumerate}


\contribution\ Все выносимые на защиту результаты получены лично автором. Программные реализации выполнены совместно с Артёмом Дергачёвым, Евгением Павловым и Юлией Трофимович.

\publications\ Основные результаты по теме диссертации изложены в 6 печатных изданиях~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine,info-2015,psi-2015},
4 из которых изданы в журналах, рекомендованных ВАК~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine}, 
2 --- в тезисах докладов~\cite{info-2015,psi-2015}. В работах \cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine} автору принадлежат теоретические модели, обзорные разделы, описание элементов разработанных методов, а также результаты экспериментального тестирования.

\textbf{Объем и структура работы.} Диссертация состоит из~введения, четырёх глав и заключения. Полный объём диссертации составляет 125 страниц с 14 рисунками и 12 таблицами. Список литературы содержит 71 наименование.

