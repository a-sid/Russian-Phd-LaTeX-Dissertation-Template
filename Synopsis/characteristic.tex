\actuality\
Для~больших и~сложных программно-технических комплексов полное покрытие всех путей выполнения программы становится невозможным, поскольку эта задача соотносится с проблемой останова. Ресурсы, выделенные на~тестирование сложных программных комплексов, всегда ограничены, что приводит к~необходимости рационального  их использования. Проблема поиска подходящего компромисса  между повышением надежности разрабатываемых программных средств и~эффективным использованием ресурсов становится все актуальнее. Для~обеспечения надёжности программных средств  активно ведётся разработка новых эффективных методов и~средств автоматического тестирования, позволяющих за~реальное время предупредить и~выявить как~можно большее количество дефектов в~программе. В~настоящее время всё большее распространение получают инструменты, предназначенные для~поиска дефектов в~программном коде.

Обычно различают статический, динамический и~смешанный анализ. Под статическим анализом понимают анализ программы, не~требующий её непосредственного выполнения. Часть инструментов, таких, как~Clang Static Analyzer \footcite{csa}, PVS-Studio \footcite{pvs}, Cppcheck \footcite{cppcheck}, Lint \footcite{lint}, исследует непосредственно код программы или структуры данные, строящиеся на~его основе,~--- абстрактное синтаксическое дерево или граф потока управления. Другая часть инструментов статического анализа использует для~анализа более низкоуровневое представление программы~--- скомпилированный объектный или промежуточный код (Svace \footcite{svace}, FindBugs \footcite{findbugs}). В~отличие от~статического анализа, для~динамического анализа программы требуется её выполнение~--- на~специальных входных данных, в~виртуальной машине (Valgrind \footcite{valgrind}), с~использованием инструментации (AddressSanitizer \footcite{asan}, ThreadSanitizer \footcite{tsan}), с~использованием дополнительных библиотек или их подменой. Наконец, смешанный анализ представляет собой комбинацию статического и~динамического анализа и~используется в~таких инструментах как~Mayhem \footcite{mayhem}, KLEE \footcite{klee}, а~также других автоматических генераторах контрпримеров.

Перечисленные виды анализа имеют свои достоинства и~недостатки, в~частности, различные виды анализа наиболее эффективны для~поиска различных видов ошибок. Статический анализ позволяет эффективно производить поиск различных видов дефектов: опечаток, некорректного использования типов, проблем безопасности, неопределённого или недокументированного поведения и~многих других видов. Инструменты для~выполнения статического анализа могут быть легко интегрированы в~процесс разработки. При~этом они могут быть использованы как~индивидуальные вспомогательные инструменты разработки (например, для~подсветки кода, содержащего потенциальную ошибку), так и~в~качестве инструментов, использующихся группой разработчиков (например, для~развёртывания и~интеграции в~систему непрерывной сборки). Сравнительно небольшое время, затрачиваемое на~анализ, вкупе с~интеграцией в~рабочий процесс позволяет быстро находить дефекты в~разрабатываемых программах.

Первоначально распространение у разработчиков получили инструменты, использующие методы на~основе анализа синтаксического дерева программы и~её графа потока управления. Преимуществами данных методов анализа программного кода являются:

\begin{itemize}
 \item высокая скорость работы и незначительное потребление памяти
 \item возможность его реализации в~компиляторе для~выполнения дополнительных проверок и~предупреждения программиста о~потенциально некорректном поведении компилируемого кода
 \item возможность интеграции в~среды разработки для~осуществления анализа <<на лету>>, непосредственно в~процессе набора кода программистом, или в~качестве дополнительного инструмента для~быстрого обнаружения дефекта.
\end{itemize}

Аналогичные методы применяются в~компиляторах для~предупреждения программиста о~потенциально некорректном поведении программы, поскольку и~синтаксическое дерево, и~граф потока управления являются основными структурами данных, с~которыми работает компилятор. Однако проверка, включаемая в~состав компилятора, должна исключать возможность ложных срабатываний, т.~е. являться консервативной. Инструменты же статического анализа могут включать также и~неконсервативные проверки, с~возможностью выдачи ложных срабатываний.

Данные методы могут обнаруживать лишь очень узкие классы дефектов в~программном коде: простые ошибки, затрагивающие лишь несколько операторов, расположенных в~пределах одной функции. Это может быть простейший поиск использования неинициализированных переменных, ошибок при~преобразовании типов, потенциально лишние операции, а~также другие дефекты, для~поиска которых не~требуется анализировать циклы и~условные переходы. Значительно более ресурсоёмким, но и~более подробным является анализ на~основе обхода путей выполнения программы. Основы этих методов были заложены ещё в~70-х~годах. Метод символьного выполнения был предложен Джеймсом Кингом в~1976 году \footcite{king76}. В~основе метода лежит идея разбиения входных данных на~классы эквивалентности в~зависимости от~встречаемых по пути выполнения условий. Метод абстрактной интерпретации, предложенный в~1977~году супругами Кузо \footcite{cousot}, предполагает использовать абстрагирование данных и~их анализ на~основе алгебры решёток. Однако данные походы стали получать распространение только в~последнее время. Это связано с~увеличившейся мощностью компьютеров: время анализа растёт пропорционально количеству путей выполнения, что означает экспоненциальный рост времени анализа с~увеличением размера программы. В~отличие от~базового анализа графа потока управления, анализ путей выполнения способен учитывать условия выполнения тех или иных ветвей программы,  следствием чего являются преимущества данного вида анализа~--- его более высокая точность и~способность покрыть намного больший класс дефектов. Такие методы, как~абстрактная интерпретация и~символьное выполнение, нашли применения в~известных инструментах для~поиска дефектов, например, Coverity SAVE и Clang Static Analyzer.

Одним из способов увеличения производительности и покрытия при использовании метода символьного выполнения является использование \textit{резюме} при межпроцедурном анализе. Этот подход позволяет повторное использование данных анализа функции для моделирования её вызовов. Исследованию этого метода посвящён ряд наиболее близких теме настоящей диссертации работ, в частности, \footcite{godefroid-comp,anand-godefroid,may-must}.

Одними из наиболее актуальных целевых языков для~статического анализа традиционно являются языки C и~C++. Во-первых, это связано с~большим количеством видов потенциальных ошибок, которые может допустить программист, ведущий разработку с~использованием этих языков. Наиболее специфичными среди таких ошибок являются ошибки, связанные с~неправильной работой с~указателями. Во-вторых, стандарты языков трактуют достаточно большое количество ситуаций как~не~имеющих определённого или зависимого от реализации поведения, что, с~одной стороны, позволяет компилятору проводить более глубокие оптимизации и~получить наибольшую скорость выполнения результирующего кода, но, с~другой стороны, требует от~программиста повышенного внимания в~процессе написания кода программы для~учёта этих особенностей. В-третьих, эти языки являются одними из самых распространённых и~известных, с~их использованием было разработано и~продолжает создаваться большое количество как~системного, так и~прикладного программного обеспечения. Кроме того, язык C является практически единственным выбором при~разработке низкоуровневых компонентов, таких как компоненты операционных систем и~драйверы, что также предъявляет повышенные требования к~качеству программного кода.

\todo{Вывод об актуальности! (NP-сложная(???)) с ограничениями, время анализа, размер программ, количество дефектов.}
 \aim\ данной работы является построение метода анализа крупных программных комплексов, разработанных с использованием языков C и C++, способного осуществлять анализ проектов масштаба ОС Android и ОС Tizen \todo{количественные характеристики} за приемлемое время и обеспечивающего достаточное покрытие путей выполнения программы.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать метод межпроцедурного анализа программ \todo{с высокой масштабируемостью (объяснить)}, пригодный для анализа крупных программных проектов, а также расширяемый на различные классы проверок
  \item Разработать метод межмодульного анализа программ, разработанных с использованием языков C и C++
  \item Разработать метод отображения результатов анализа при использовании разработанного метода межпроцедурного анализа
  \item Для экспериментального подтверждения эффективности предложенных методов реализовать их для использования в приложении-анализаторе (Clang Static Analyzer, анализатор с открытым исходным кодом) и осуществить тестирование разработанных методов на реальных программных проектах~--- пакетах пользовательского окружения ОС Android
  \item По результатам тестирования сделать выводы о пригодности разработанного метода, о его масштабируемости и качестве анализа кода программ
\end{enumerate}

\defpositions
\begin{enumerate}
  \item Метод межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, разработанных с использованием языков C и C++
  \item Метод межмодульного анализа программ, разработанных с использованием языков C и C++, архитектура анализатора, эвристики, связанные с объединением синтаксических деревьев различных модулей трансляции
  \item Метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
\end{enumerate}

\novelty

В работе получены следующие основные результаты, обладающие научной новизной:
\todo{Написать о работе в классе задач по сложности}
\begin{enumerate}
  \item Разработан метод межпроцедурного анализа программ на основе резюме для метода символьного выполнения для программ, реализованных с использованием языков C и C++
  \item Разработан метод межмодульного анализа программ, разработанных с использованием языков C и C++ для статического анализатора, использующего в качестве входных данных непосредственно исходный код программы
  \item Разработан метод построения отчёта о дефекте при использовании метода резюме для метода символьного выполнения
%  \item Вышеперечисленные методы реализованы с использованием инфраструктуры статического анализатора Clang Static Analyzer и апробированы на реальных проектах (ОС Android)
\end{enumerate}

\influence\ Разработаны методы анализа программ, применимые для проектов масштаба операционных систем и их наборов пользовательских приложений. Программное обеспечение, реализующее разработанные методы, внедрено в Samsung Electronics и используется для анализа исходного кода ПО различного назначения, в частности, мобильных приложений и операционных систем, телевизионное ПО, ПО медицинских систем, и может использоваться для других программных систем, включая настольные приложения и крупные системы управления.
\todo{Добавить здесь о результатах тестирования}

\reliability\ полученных результатов обеспечивается экспериментальным подтверждением и последующей ручной проверкой отчётов анализатора при анализе исходного кода ОС Android версии 4.2.1. \todo{Качество анализа оценивалось... в результате чего были подтверждено отсутствие изменений качества анализа (в обоих случаях доля корректных срабатываний составила от 80\% до 84\% в зависимости от настроек анализатора)}. Ряд обнаруженных дефектов обнаруживается с использованием других статических анализаторов, например, Coverity SAVE или Clang Static Analyzer (с режимом встраивания). Для тестирования был использован открытый исходный код, а разработанная экспериментальная система помещена в открытый доступ, что позволяет воспроизвести эксперименты независимо. \todo{Здесь нужно точно!} Теоретические выводы о \todo{...}, сделанные в данной работе, подтверждены в ряде других работ \todo{перечислить} 

\probation\
Основные результаты работы докладывались~на:
\begin{enumerate}
 \item 10-й Международной Ершовской конференции <<Перспективы систем информатики>> (PSI 2015) \todo{ссылка} (Казань, Россия, 2015)
 \item XII Международной научно-практической конференции <<Инновации на основе информационных и коммуникационных технологий>> (INFO-2015) (Сочи, Россия, 2015) \todo{link}
 \item \todo{Открытом семинаре....}
\end{enumerate}


\contribution\ Все выносимые на защиту результаты получены лично автором. 

\publications\ Основные результаты по теме диссертации изложены в 6 печатных изданиях~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine,info-2015,psi-2015},
4 из которых изданы в журналах, рекомендованных ВАК~\cite{summary-impl-mine,summary-intro-mine,summary-inter-unit-mine,summary-checkers-mine}, 
2 --- в тезисах докладов~\cite{info-2015,psi-2015}. \todo{Написать о соавторстве}
